// Auto-generated by R3D-cs.GenerateBindings
// Do not edit manually

using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using Raylib_cs;
using static Raylib_cs.Raylib;

[assembly: DisableRuntimeMarshalling]

namespace R3D_cs;

[SuppressUnmanagedCodeSecurity]
public static unsafe partial class R3D
{
    public const string NativeLibName = "r3d";

    /// <summary>
    /// Loads a cubemap from an image file.
    /// <para>
    /// The layout parameter tells how faces are arranged inside the source image.
    /// </para>
    /// </summary>
    /// <seealso>R3D_LoadCubemap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadCubemap", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Cubemap LoadCubemap(string fileName, CubemapLayout layout);

    /// <summary>
    /// Builds a cubemap from an existing Image.
    /// <para>
    /// Same behavior as R3D_LoadCubemap(), but without loading from disk.
    /// </para>
    /// </summary>
    /// <seealso>R3D_LoadCubemapFromImage</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadCubemapFromImage")]
    public static partial Cubemap LoadCubemapFromImage(Image image, CubemapLayout layout);

    /// <summary>
    /// Generates a procedural sky cubemap.
    /// <para>
    /// Creates a GPU cubemap with procedural gradient sky and sun rendering. The cubemap is ready for use as environment map or IBL source.
    /// </para>
    /// </summary>
    /// <seealso>R3D_GenCubemapSky</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenCubemapSky")]
    public static partial Cubemap GenCubemapSky(int size, CubemapSky @params);

    /// <summary>
    /// Releases GPU resources associated with a cubemap.
    /// </summary>
    /// <seealso>R3D_UnloadCubemap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadCubemap")]
    public static partial void UnloadCubemap(Cubemap cubemap);

    /// <summary>
    /// Updates an existing procedural sky cubemap.
    /// <para>
    /// Re-renders the cubemap with new parameters. Faster than unload + generate when animating sky conditions (time of day, weather, etc.).
    /// </para>
    /// </summary>
    /// <seealso>R3D_UpdateCubemapSky</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UpdateCubemapSky")]
    public static partial void UpdateCubemapSky(ref Cubemap cubemap, CubemapSky @params);

    /// <summary>
    /// Loads a ambient map from an image file.
    /// <para>
    /// The layout parameter tells how faces are arranged inside the source image.
    /// </para>
    /// </summary>
    /// <seealso>R3D_LoadAmbientMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadAmbientMap", StringMarshalling = StringMarshalling.Utf8)]
    public static partial AmbientMap LoadAmbientMap(string fileName, CubemapLayout layout, AmbientFlags flags);

    /// <summary>
    /// Builds a ambient map from an existing Image.
    /// <para>
    /// Same behavior as R3D_LoadAmbientMap(), but without loading from disk.
    /// </para>
    /// </summary>
    /// <seealso>R3D_LoadAmbientMapFromImage</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadAmbientMapFromImage")]
    public static partial AmbientMap LoadAmbientMapFromImage(Image image, CubemapLayout layout, AmbientFlags flags);

    /// <summary>
    /// Generates an ambient map from a cubemap.
    /// <para>
    /// The source cubemap should usually be an HDR sky/environment.
    /// </para>
    /// <para>
    /// Depending on the provided flags, this function:
    /// <list type="bullet">
    /// <item><description>convolves the cubemap into diffuse irradiance</description></item>
    /// <item><description>builds a mipmapped prefiltered cubemap for reflections</description></item>
    /// </list>
    /// </para>
    /// </summary>
    /// <param name="cubemap">Source cubemap (environment / sky).</param>
    /// <param name="flags">Which components to generate (irradiance, reflection, or both).</param>
    /// <returns>A fully initialized ambient map.</returns>
    /// <seealso>R3D_GenAmbientMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenAmbientMap")]
    public static partial AmbientMap GenAmbientMap(Cubemap cubemap, AmbientFlags flags);

    /// <summary>
    /// Frees the textures used by an ambient map.
    /// <para>
    /// After this call, the ambient map is no longer valid.
    /// </para>
    /// </summary>
    /// <seealso>R3D_UnloadAmbientMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadAmbientMap")]
    public static partial void UnloadAmbientMap(AmbientMap ambientMap);

    /// <summary>
    /// Rebuilds an existing ambient map from a new cubemap.
    /// <para>
    /// Use this when the environment changes dynamically (time of day, weather, interior/exterior transitions, etc).
    /// </para>
    /// <para>
    /// Only the components enabled in `ambientMap.flags` are regenerated.
    /// </para>
    /// </summary>
    /// <param name="ambientMap">Existing ambient map to update.</param>
    /// <param name="cubemap">New cubemap source.</param>
    /// <seealso>R3D_UpdateAmbientMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UpdateAmbientMap")]
    public static partial void UpdateAmbientMap(AmbientMap ambientMap, Cubemap cubemap);

    /// <summary>
    /// Load an importer from a file.
    /// <para>
    /// Creates an importer instance from the specified file path. The file is parsed once and can be reused to extract multiple resources such as models and animations.
    /// </para>
    /// </summary>
    /// <param name="filePath">Path to the asset file.</param>
    /// <param name="flags">Importer behavior flags.</param>
    /// <returns>Pointer to a new importer instance, or NULL on failure.</returns>
    /// <seealso>R3D_LoadImporter</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadImporter", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Importer* LoadImporter(string filePath, ImportFlags flags);

    /// <summary>
    /// Load an importer from a memory buffer.
    /// <para>
    /// Creates an importer instance from in-memory asset data. This is useful for embedded assets or streamed content.
    /// </para>
    /// </summary>
    /// <param name="data">Pointer to the asset data.</param>
    /// <param name="size">Size of the data buffer in bytes.</param>
    /// <param name="hint">Optional file format hint (may be NULL).</param>
    /// <param name="flags">Importer behavior flags.</param>
    /// <returns>Pointer to a new importer instance, or NULL on failure.</returns>
    /// <seealso>R3D_LoadImporterFromMemory</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadImporterFromMemory", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Importer* LoadImporterFromMemory(void* data, uint size, string hint, ImportFlags flags);

    /// <summary>
    /// Destroy an importer instance.
    /// <para>
    /// Frees all resources associated with the importer. Any models or animations extracted from it remain valid.
    /// </para>
    /// </summary>
    /// <param name="importer">Importer instance to destroy.</param>
    /// <seealso>R3D_UnloadImporter</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadImporter")]
    public static partial void UnloadImporter(Importer* importer);

    /// <summary>
    /// Loads animations from a model file.
    /// </summary>
    /// <param name="filePath">Path to the model file containing animations.</param>
    /// <param name="targetFrameRate">Desired frame rate (FPS) for sampling the animations.</param>
    /// <returns>Pointer to an array of R3D_Animation, or NULL on failure.</returns>
    /// <remarks>
    /// Free the returned array using R3D_UnloadAnimationLib().
    /// </remarks>
    /// <seealso>R3D_LoadAnimationLib</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadAnimationLib", StringMarshalling = StringMarshalling.Utf8)]
    public static partial AnimationLib LoadAnimationLib(string filePath);

    /// <summary>
    /// Loads animations from memory data.
    /// </summary>
    /// <param name="data">Pointer to memory buffer containing model animation data.</param>
    /// <param name="size">Size of the buffer in bytes.</param>
    /// <param name="hint">Hint on the model format (can be NULL).</param>
    /// <param name="targetFrameRate">Desired frame rate (FPS) for sampling the animations.</param>
    /// <returns>Pointer to an array of R3D_Animation, or NULL on failure.</returns>
    /// <remarks>
    /// Free the returned array using R3D_UnloadAnimationLib().
    /// </remarks>
    /// <seealso>R3D_LoadAnimationLibFromMemory</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadAnimationLibFromMemory", StringMarshalling = StringMarshalling.Utf8)]
    public static partial AnimationLib LoadAnimationLibFromMemory(void* data, uint size, string hint);

    /// <summary>
    /// Loads animations from an existing importer.
    /// </summary>
    /// <param name="importer">Importer instance containing animation data.</param>
    /// <returns>Pointer to an array of R3D_Animation, or NULL on failure.</returns>
    /// <remarks>
    /// Free the returned array using R3D_UnloadAnimationLib().
    /// </remarks>
    /// <seealso>R3D_LoadAnimationLibFromImporter</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadAnimationLibFromImporter")]
    public static partial AnimationLib LoadAnimationLibFromImporter(Importer* importer);

    /// <summary>
    /// Releases all resources associated with an animation library.
    /// </summary>
    /// <param name="animLib">Animation library to unload.</param>
    /// <seealso>R3D_UnloadAnimationLib</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadAnimationLib")]
    public static partial void UnloadAnimationLib(AnimationLib animLib);

    /// <summary>
    /// Returns the index of an animation by name.
    /// </summary>
    /// <param name="animLib">Animation library to search.</param>
    /// <param name="name">Name of the animation (case-sensitive).</param>
    /// <returns>Zero-based index if found, or -1 if not found.</returns>
    /// <seealso>R3D_GetAnimationIndex</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetAnimationIndex", StringMarshalling = StringMarshalling.Utf8)]
    public static partial int GetAnimationIndex(AnimationLib animLib, string name);

    /// <summary>
    /// Retrieves an animation by name.
    /// </summary>
    /// <param name="animLib">Animation library to search.</param>
    /// <param name="name">Name of the animation (case-sensitive).</param>
    /// <returns>Pointer to the animation, or NULL if not found.</returns>
    /// <seealso>R3D_GetAnimation</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetAnimation", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Animation* GetAnimation(AnimationLib animLib, string name);

    /// <summary>
    /// Loads a skeleton hierarchy from a 3D model file.
    /// <para>
    /// Skeletons are automatically loaded when importing a model, but can be loaded manually for advanced use cases.
    /// </para>
    /// </summary>
    /// <param name="filePath">Path to the model file containing the skeleton data.</param>
    /// <returns>Return the loaded R3D_Skeleton.</returns>
    /// <seealso>R3D_LoadSkeleton</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadSkeleton", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Skeleton LoadSkeleton(string filePath);

    /// <summary>
    /// Loads a skeleton hierarchy from memory data.
    /// <para>
    /// Allows manual loading of skeletons directly from a memory buffer. Typically used for advanced or custom asset loading workflows.
    /// </para>
    /// </summary>
    /// <param name="data">Pointer to the memory buffer containing skeleton data.</param>
    /// <param name="size">Size of the memory buffer in bytes.</param>
    /// <param name="hint">Optional format hint (can be NULL).</param>
    /// <returns>Return the loaded R3D_Skeleton.</returns>
    /// <seealso>R3D_LoadSkeletonFromMemory</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadSkeletonFromMemory", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Skeleton LoadSkeletonFromMemory(void* data, uint size, string hint);

    /// <summary>
    /// Loads a skeleton hierarchy from an existing importer.
    /// <para>
    /// Extracts the skeleton data from a previously loaded importer instance.
    /// </para>
    /// </summary>
    /// <param name="importer">Importer instance to extract the skeleton from.</param>
    /// <returns>Return the loaded R3D_Skeleton.</returns>
    /// <seealso>R3D_LoadSkeletonFromImporter</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadSkeletonFromImporter")]
    public static partial Skeleton LoadSkeletonFromImporter(Importer* importer);

    /// <summary>
    /// Frees the memory allocated for a skeleton.
    /// </summary>
    /// <param name="skeleton">R3D_Skeleton to destroy.</param>
    /// <seealso>R3D_UnloadSkeleton</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadSkeleton")]
    public static partial void UnloadSkeleton(Skeleton skeleton);

    /// <summary>
    /// Check if a skeleton is valid.
    /// <para>
    /// Returns true if atleast the texBindPose is greater than zero.
    /// </para>
    /// </summary>
    /// <param name="skeleton">The skeleton to check.</param>
    /// <returns>true if valid, false otherwise.</returns>
    /// <seealso>R3D_IsSkeletonValid</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsSkeletonValid")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsSkeletonValid(Skeleton skeleton);

    /// <summary>
    /// Returns the index of the bone with the given name.
    /// </summary>
    /// <param name="skeleton">Skeleton to search in.</param>
    /// <param name="boneName">Name of the bone to find.</param>
    /// <returns>Index of the bone, or a negative value if not found.</returns>
    /// <seealso>R3D_GetSkeletonBoneIndex</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetSkeletonBoneIndex", StringMarshalling = StringMarshalling.Utf8)]
    public static partial int GetSkeletonBoneIndex(Skeleton skeleton, string boneName);

    /// <summary>
    /// Returns a pointer to the bone with the given name.
    /// </summary>
    /// <param name="skeleton">Skeleton to search in.</param>
    /// <param name="boneName">Name of the bone to find.</param>
    /// <returns>Pointer to the bone, or NULL if not found.</returns>
    /// <seealso>R3D_GetSkeletonBone</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetSkeletonBone", StringMarshalling = StringMarshalling.Utf8)]
    public static partial BoneInfo* GetSkeletonBone(Skeleton skeleton, string boneName);

    /// <summary>
    /// Creates an animation player for a skeleton and animation library.
    /// <para>
    /// Allocates memory for animation states and pose buffers.
    /// </para>
    /// </summary>
    /// <param name="skeleton">Skeleton to animate.</param>
    /// <param name="animLib">Animation library providing animations.</param>
    /// <returns>Newly created animation player, or a zeroed struct on failure.</returns>
    /// <seealso>R3D_LoadAnimationPlayer</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadAnimationPlayer")]
    public static partial AnimationPlayer LoadAnimationPlayer(Skeleton skeleton, AnimationLib animLib);

    /// <summary>
    /// Releases all resources used by an animation player.
    /// </summary>
    /// <param name="player">Animation player to unload.</param>
    /// <seealso>R3D_UnloadAnimationPlayer</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadAnimationPlayer")]
    public static partial void UnloadAnimationPlayer(AnimationPlayer player);

    /// <summary>
    /// Checks whether an animation player is valid.
    /// </summary>
    /// <param name="player">Animation player to check.</param>
    /// <returns>true if valid, false otherwise.</returns>
    /// <seealso>R3D_IsAnimationPlayerValid</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsAnimationPlayerValid")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsAnimationPlayerValid(AnimationPlayer player);

    /// <summary>
    /// Returns whether a given animation is currently playing.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <returns>true if playing, false otherwise.</returns>
    /// <seealso>R3D_IsAnimationPlaying</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsAnimationPlaying")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsAnimationPlaying(AnimationPlayer player, int animIndex);

    /// <summary>
    /// Starts playback of the specified animation.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation to play.</param>
    /// <seealso>R3D_PlayAnimation</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_PlayAnimation")]
    public static partial void PlayAnimation(ref AnimationPlayer player, int animIndex);

    /// <summary>
    /// Pauses the specified animation.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation to pause.</param>
    /// <seealso>R3D_PauseAnimation</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_PauseAnimation")]
    public static partial void PauseAnimation(ref AnimationPlayer player, int animIndex);

    /// <summary>
    /// Stops the specified animation and clamps its time.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation to stop.</param>
    /// <seealso>R3D_StopAnimation</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_StopAnimation")]
    public static partial void StopAnimation(ref AnimationPlayer player, int animIndex);

    /// <summary>
    /// Rewinds the animation to the start or end depending on playback direction.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation to rewind.</param>
    /// <seealso>R3D_RewindAnimation</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_RewindAnimation")]
    public static partial void RewindAnimation(ref AnimationPlayer player, int animIndex);

    /// <summary>
    /// Gets the current playback time of an animation.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <returns>Current time in animation ticks.</returns>
    /// <seealso>R3D_GetAnimationTime</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetAnimationTime")]
    public static partial float GetAnimationTime(AnimationPlayer player, int animIndex);

    /// <summary>
    /// Sets the current playback time of an animation.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <param name="time">Time in animation ticks.</param>
    /// <seealso>R3D_SetAnimationTime</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetAnimationTime")]
    public static partial void SetAnimationTime(ref AnimationPlayer player, int animIndex, float time);

    /// <summary>
    /// Gets the blending weight of an animation.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <returns>Current weight.</returns>
    /// <seealso>R3D_GetAnimationWeight</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetAnimationWeight")]
    public static partial float GetAnimationWeight(AnimationPlayer player, int animIndex);

    /// <summary>
    /// Sets the blending weight of an animation.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <param name="weight">Blending weight to apply.</param>
    /// <seealso>R3D_SetAnimationWeight</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetAnimationWeight")]
    public static partial void SetAnimationWeight(ref AnimationPlayer player, int animIndex, float weight);

    /// <summary>
    /// Gets the playback speed of an animation.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <returns>Current speed (may be negative for reverse playback).</returns>
    /// <seealso>R3D_GetAnimationSpeed</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetAnimationSpeed")]
    public static partial float GetAnimationSpeed(AnimationPlayer player, int animIndex);

    /// <summary>
    /// Sets the playback speed of an animation.
    /// <para>
    /// Negative values play the animation backwards. If setting a negative speed on a stopped animation, consider calling RewindAnimation() to start at the end.
    /// </para>
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <param name="speed">Playback speed.</param>
    /// <seealso>R3D_SetAnimationSpeed</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetAnimationSpeed")]
    public static partial void SetAnimationSpeed(ref AnimationPlayer player, int animIndex, float speed);

    /// <summary>
    /// Gets whether the animation is set to loop.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <returns>True if looping is enabled.</returns>
    /// <seealso>R3D_GetAnimationLoop</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetAnimationLoop")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool GetAnimationLoop(AnimationPlayer player, int animIndex);

    /// <summary>
    /// Enables or disables looping for the animation.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="animIndex">Index of the animation.</param>
    /// <param name="loop">True to enable looping.</param>
    /// <seealso>R3D_SetAnimationLoop</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetAnimationLoop")]
    public static partial void SetAnimationLoop(ref AnimationPlayer player, int animIndex, [MarshalAs(UnmanagedType.I1)] bool loop);

    /// <summary>
    /// Advances the time of all active animations.
    /// <para>
    /// Updates all internal animation timers based on speed and delta time. Does NOT recalculate the skeleton pose.
    /// </para>
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="dt">Delta time in seconds.</param>
    /// <seealso>R3D_AdvanceAnimationPlayerTime</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_AdvanceAnimationPlayerTime")]
    public static partial void AdvanceAnimationPlayerTime(ref AnimationPlayer player, float dt);

    /// <summary>
    /// Calculates the current blended local pose of the skeleton.
    /// <para>
    /// Interpolates keyframes and blends all active animations according to their weights, but only computes the local transforms of each bone relative to its parent. Does NOT advance animation time.
    /// </para>
    /// </summary>
    /// <param name="player">Animation player whose local pose will be updated.</param>
    /// <seealso>R3D_CalculateAnimationPlayerLocalPose</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CalculateAnimationPlayerLocalPose")]
    public static partial void CalculateAnimationPlayerLocalPose(ref AnimationPlayer player);

    /// <summary>
    /// Calculates the current blended model (global) pose of the skeleton.
    /// <para>
    /// Interpolates keyframes and blends all active animations according to their weights, but only computes the global transforms of each bone in model space. This assumes the local pose is already up-to-date. Does NOT advance animation time.
    /// </para>
    /// </summary>
    /// <param name="player">Animation player whose model pose will be updated.</param>
    /// <seealso>R3D_CalculateAnimationPlayerModelPose</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CalculateAnimationPlayerModelPose")]
    public static partial void CalculateAnimationPlayerModelPose(ref AnimationPlayer player);

    /// <summary>
    /// Calculates the current blended skeleton pose (local and model).
    /// <para>
    /// Interpolates keyframes and blends all active animations according to their weights, then computes both local and model transforms for the entire skeleton. Does NOT advance animation time.
    /// </para>
    /// </summary>
    /// <param name="player">Animation player whose local and model poses will be updated.</param>
    /// <seealso>R3D_CalculateAnimationPlayerPose</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CalculateAnimationPlayerPose")]
    public static partial void CalculateAnimationPlayerPose(ref AnimationPlayer player);

    /// <summary>
    /// Calculates the skinning matrices and uploads them to the GPU.
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <seealso>R3D_UploadAnimationPlayerPose</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UploadAnimationPlayerPose")]
    public static partial void UploadAnimationPlayerPose(ref AnimationPlayer player);

    /// <summary>
    /// Updates the animation player: calculates and upload blended pose, then advances time.
    /// <para>
    /// Equivalent to calling R3D_CalculateAnimationPlayerPose() followed by R3D_UploadAnimationPlayerPose() and R3D_AdvanceAnimationPlayerTime().
    /// </para>
    /// </summary>
    /// <param name="player">Animation player.</param>
    /// <param name="dt">Delta time in seconds.</param>
    /// <seealso>R3D_UpdateAnimationPlayer</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UpdateAnimationPlayer")]
    public static partial void UpdateAnimationPlayer(ref AnimationPlayer player, float dt);

    /// <summary>
    /// Initializes the rendering engine.
    /// <para>
    /// This function sets up the internal rendering system with the provided resolution.
    /// </para>
    /// </summary>
    /// <param name="resWidth">Width of the internal resolution.</param>
    /// <param name="resHeight">Height of the internal resolution.</param>
    /// <seealso>R3D_Init</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_Init")]
    public static partial void Init(int resWidth, int resHeight);

    /// <summary>
    /// Closes the rendering engine and deallocates all resources.
    /// <para>
    /// This function shuts down the rendering system and frees all allocated memory, including the resources associated with the created lights.
    /// </para>
    /// </summary>
    /// <seealso>R3D_Close</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_Close")]
    public static partial void Close();

    /// <summary>
    /// Gets the current internal resolution.
    /// <para>
    /// This function retrieves the current internal resolution being used by the rendering engine.
    /// </para>
    /// </summary>
    /// <param name="width">Pointer to store the width of the internal resolution.</param>
    /// <param name="height">Pointer to store the height of the internal resolution.</param>
    /// <seealso>R3D_GetResolution</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetResolution")]
    public static partial void GetResolution(out int width, out int height);

    /// <summary>
    /// Updates the internal resolution.
    /// <para>
    /// This function changes the internal resolution of the rendering engine. Note that this process destroys and recreates all framebuffers, which may be a slow operation.
    /// </para>
    /// </summary>
    /// <param name="width">The new width for the internal resolution.</param>
    /// <param name="height">The new height for the internal resolution.</param>
    /// <remarks>
    /// <b>Warning:</b>
    /// This function may be slow due to the destruction and recreation of framebuffers.
    /// </remarks>
    /// <seealso>R3D_UpdateResolution</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UpdateResolution")]
    public static partial void UpdateResolution(int width, int height);

    /// <summary>
    /// Retrieves the current anti-aliasing mode used for rendering.
    /// </summary>
    /// <returns>The currently active R3D_AntiAliasing mode.</returns>
    /// <seealso>R3D_GetAntiAliasing</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetAntiAliasing")]
    public static partial AntiAliasing GetAntiAliasing();

    /// <summary>
    /// Sets the anti-aliasing mode for rendering.
    /// </summary>
    /// <param name="mode">The desired R3D_AntiAliasing mode.</param>
    /// <seealso>R3D_SetAntiAliasing</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetAntiAliasing")]
    public static partial void SetAntiAliasing(AntiAliasing mode);

    /// <summary>
    /// Retrieves the current aspect ratio handling mode.
    /// </summary>
    /// <returns>The currently active R3D_AspectMode.</returns>
    /// <seealso>R3D_GetAspectMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetAspectMode")]
    public static partial AspectMode GetAspectMode();

    /// <summary>
    /// Sets the aspect ratio handling mode for rendering.
    /// </summary>
    /// <param name="mode">The desired R3D_AspectMode.</param>
    /// <seealso>R3D_SetAspectMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetAspectMode")]
    public static partial void SetAspectMode(AspectMode mode);

    /// <summary>
    /// Retrieves the current upscaling/filtering method.
    /// </summary>
    /// <returns>The currently active R3D_UpscaleMode.</returns>
    /// <seealso>R3D_GetUpscaleMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetUpscaleMode")]
    public static partial UpscaleMode GetUpscaleMode();

    /// <summary>
    /// Sets the upscaling/filtering method for rendering output.
    /// </summary>
    /// <param name="mode">The desired R3D_UpscaleMode.</param>
    /// <seealso>R3D_SetUpscaleMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetUpscaleMode")]
    public static partial void SetUpscaleMode(UpscaleMode mode);

    /// <summary>
    /// Retrieves the current downscaling mode used for rendering.
    /// </summary>
    /// <returns>The currently active R3D_DownscaleMode.</returns>
    /// <seealso>R3D_GetDownscaleMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetDownscaleMode")]
    public static partial DownscaleMode GetDownscaleMode();

    /// <summary>
    /// Sets the downscaling mode for rendering output.
    /// </summary>
    /// <param name="mode">The desired R3D_DownscaleMode.</param>
    /// <seealso>R3D_SetDownscaleMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetDownscaleMode")]
    public static partial void SetDownscaleMode(DownscaleMode mode);

    /// <summary>
    /// Gets the current output mode.
    /// </summary>
    /// <returns>The currently active R3D_OutputMode.</returns>
    /// <seealso>R3D_GetOutputMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetOutputMode")]
    public static partial OutputMode GetOutputMode();

    /// <summary>
    /// Sets the output mode for rendering.
    /// </summary>
    /// <param name="mode">The R3D_OutputMode to use.</param>
    /// <remarks>
    /// Nothing will be output if the requested target has not been created / used.
    /// </remarks>
    /// <seealso>R3D_SetOutputMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetOutputMode")]
    public static partial void SetOutputMode(OutputMode mode);

    /// <summary>
    /// Sets the default texture filtering mode.
    /// <para>
    /// This function defines the default texture filter that will be applied to all subsequently loaded textures, including those used in materials, sprites, and other resources.
    /// </para>
    /// <para>
    /// If a trilinear or anisotropic filter is selected, mipmaps will be automatically generated for the textures, but they will not be generated when using nearest or bilinear filtering.
    /// </para>
    /// <para>
    /// The default texture filter mode is `TEXTURE_FILTER_TRILINEAR`.
    /// </para>
    /// </summary>
    /// <param name="filter">The texture filtering mode to be applied by default.</param>
    /// <seealso>R3D_SetTextureFilter</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetTextureFilter")]
    public static partial void SetTextureFilter(TextureFilter filter);

    /// <summary>
    /// Set the working color space for user-provided surface colors and color textures.
    /// <para>
    /// Defines how all *color inputs* should be interpreted:
    /// <list type="bullet">
    /// <item><description>surface colors provided in materials (e.g. albedo/emission tints)</description></item>
    /// <item><description>color textures such as albedo and emission maps</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// When set to sRGB, these values are converted to linear before shading. When set to linear, values are used as-is.
    /// </para>
    /// <para>
    /// This does NOT affect lighting inputs (direct or indirect light), which are always expected to be provided in linear space.
    /// </para>
    /// <para>
    /// The default color space is `R3D_COLORSPACE_SRGB`.
    /// </para>
    /// </summary>
    /// <param name="space">Color space to use for color inputs (linear or sRGB).</param>
    /// <seealso>R3D_SetColorSpace</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetColorSpace")]
    public static partial void SetColorSpace(ColorSpace space);

    /// <summary>
    /// Get the currently active global rendering layers.
    /// <para>
    /// Returns the bitfield representing the currently active layers in the renderer. By default, the internal active layers are set to 0, which means that any non-zero layer assigned to an object will NOT be rendered unless explicitly activated.
    /// </para>
    /// </summary>
    /// <returns>R3D_Layer Bitfield of active layers.</returns>
    /// <seealso>R3D_GetActiveLayers</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetActiveLayers")]
    public static partial Layer GetActiveLayers();

    /// <summary>
    /// Set the active global rendering layers.
    /// <para>
    /// Replaces the current set of active layers with the given bitfield.
    /// </para>
    /// </summary>
    /// <param name="bitfield">Bitfield representing the layers to activate.</param>
    /// <seealso>R3D_SetActiveLayers</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetActiveLayers")]
    public static partial void SetActiveLayers(Layer bitfield);

    /// <summary>
    /// Enable one or more layers without affecting other active layers.
    /// <para>
    /// This function sets the bits in the global active layers corresponding to the bits in the provided bitfield. Layers already active remain active.
    /// </para>
    /// </summary>
    /// <param name="bitfield">Bitfield representing one or more layers to enable.</param>
    /// <seealso>R3D_EnableLayers</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_EnableLayers")]
    public static partial void EnableLayers(Layer bitfield);

    /// <summary>
    /// Disable one or more layers without affecting other active layers.
    /// <para>
    /// This function clears the bits in the global active layers corresponding to the bits in the provided bitfield. Layers not included in the bitfield remain unchanged.
    /// </para>
    /// </summary>
    /// <param name="bitfield">Bitfield representing one or more layers to disable.</param>
    /// <seealso>R3D_DisableLayers</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DisableLayers")]
    public static partial void DisableLayers(Layer bitfield);

    /// <summary>
    /// Checks if a point is inside the view frustum.
    /// <para>
    /// Tests whether a 3D point lies within the camera's frustum by checking against all six planes. Call this only between `R3D_Begin` and `R3D_End`.
    /// </para>
    /// <para>
    /// Useful when automatic frustum culling is disabled and you're using a custom spatial structure (e.g., octree, BVH, etc.).
    /// </para>
    /// </summary>
    /// <param name="position">The 3D point to test.</param>
    /// <returns>`true` if inside the frustum, `false` otherwise.</returns>
    /// <remarks>
    /// <b>Warning:</b>
    /// Frustum culling may incorrectly discard objects casting visible shadows.
    /// This performs an exact plane-point test. Slower than bounding box tests.
    /// </remarks>
    /// <seealso>R3D_IsPointInFrustum</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsPointInFrustum")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsPointInFrustum(Vector3 position);

    /// <summary>
    /// Checks if a sphere is inside the view frustum.
    /// <para>
    /// Tests whether a sphere intersects the camera's frustum using plane-sphere tests. Call this only between `R3D_Begin` and `R3D_End`.
    /// </para>
    /// <para>
    /// Useful when managing visibility manually.
    /// </para>
    /// </summary>
    /// <param name="position">The center of the sphere.</param>
    /// <param name="radius">The sphere's radius (must be positive).</param>
    /// <returns>`true` if at least partially inside the frustum, `false` otherwise.</returns>
    /// <remarks>
    /// <b>Warning:</b>
    /// May cause visual issues with shadow casters being culled too early.
    /// More accurate but slower than bounding box approximations.
    /// </remarks>
    /// <seealso>R3D_IsSphereInFrustum</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsSphereInFrustum")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsSphereInFrustum(Vector3 position, float radius);

    /// <summary>
    /// Checks if an AABB is inside the view frustum.
    /// <para>
    /// Determines whether an axis-aligned bounding box intersects the frustum. Call between `R3D_Begin` and `R3D_End`.
    /// </para>
    /// <para>
    /// For use in custom culling strategies or spatial partitioning systems.
    /// </para>
    /// </summary>
    /// <param name="aabb">The bounding box to test.</param>
    /// <returns>`true` if at least partially inside the frustum, `false` otherwise.</returns>
    /// <remarks>
    /// <b>Warning:</b>
    /// May prematurely cull objects casting visible shadows.
    /// Exact but more costly than AABB pre-tests.
    /// </remarks>
    /// <seealso>R3D_IsAABBInFrustum</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsAABBInFrustum")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsAABBInFrustum(BoundingBox aabb);

    /// <summary>
    /// Checks if an OBB is inside the view frustum.
    /// <para>
    /// Tests an oriented bounding box (transformed AABB) for frustum intersection. Must be called between `R3D_Begin` and `R3D_End`.
    /// </para>
    /// <para>
    /// Use this for objects with transformations when doing manual culling.
    /// </para>
    /// </summary>
    /// <param name="aabb">Local-space bounding box.</param>
    /// <param name="transform">World-space transform matrix.</param>
    /// <returns>`true` if the transformed box intersects the frustum, `false` otherwise.</returns>
    /// <remarks>
    /// <b>Warning:</b>
    /// May incorrectly cull shadow casters.
    /// More expensive than AABB checks due to matrix operations.
    /// </remarks>
    /// <seealso>R3D_IsOBBInFrustum</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsOBBInFrustum")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsOBBInFrustum(BoundingBox aabb, Matrix4x4 transform);

    /// <summary>
    /// Get the default material configuration.
    /// <para>
    /// Returns `R3D_MATERIAL_BASE` by default, or the material defined via `R3D_SetDefaultMaterial()`.
    /// </para>
    /// </summary>
    /// <returns>Default material structure with standard properties.</returns>
    /// <seealso>R3D_GetDefaultMaterial</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetDefaultMaterial")]
    public static partial Material GetDefaultMaterial();

    /// <summary>
    /// Set the default material configuration.
    /// <para>
    /// Allows you to override the default material. The default material will be used as the basis for loading 3D models.
    /// </para>
    /// </summary>
    /// <param name="material">Default material to define.</param>
    /// <seealso>R3D_SetDefaultMaterial</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetDefaultMaterial")]
    public static partial void SetDefaultMaterial(Material material);

    /// <summary>
    /// Unload a material and its associated textures.
    /// <para>
    /// Frees all memory associated with a material, including its textures. This function will unload all textures that are not default textures.
    /// </para>
    /// </summary>
    /// <param name="material">Pointer to the material structure to be unloaded.</param>
    /// <remarks>
    /// <b>Warning:</b>
    /// Only call this function if you are certain that the textures are not shared with other materials or objects, as this will permanently free the texture data.
    /// </remarks>
    /// <seealso>R3D_UnloadMaterial</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadMaterial")]
    public static partial void UnloadMaterial(Material material);

    /// <summary>
    /// Load an albedo (base color) map from file.
    /// <para>
    /// Loads an image, uploads it as an sRGB texture (if enabled), and applies the provided tint color.
    /// </para>
    /// </summary>
    /// <param name="fileName">Path to the texture file.</param>
    /// <param name="color">Multiplicative tint applied in the shader.</param>
    /// <returns>Albedo map structure. Returns an empty map on failure.</returns>
    /// <seealso>R3D_LoadAlbedoMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadAlbedoMap", StringMarshalling = StringMarshalling.Utf8)]
    public static partial AlbedoMap LoadAlbedoMap(string fileName, Color color);

    /// <summary>
    /// Load an albedo (base color) map from memory.
    /// <para>
    /// Same behavior as R3D_LoadAlbedoMap(), but reads from memory instead of disk.
    /// </para>
    /// </summary>
    /// <param name="fileType">Image format hint (e.g. &quot;png&quot;, &quot;jpg&quot;).</param>
    /// <param name="fileData">Pointer to image data.</param>
    /// <param name="dataSize">Size of image data in bytes.</param>
    /// <param name="color">Multiplicative tint applied in the shader.</param>
    /// <returns>Albedo map structure. Returns an empty map on failure.</returns>
    /// <seealso>R3D_LoadAlbedoMapFromMemory</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadAlbedoMapFromMemory", StringMarshalling = StringMarshalling.Utf8)]
    public static partial AlbedoMap LoadAlbedoMapFromMemory(string fileType, void* fileData, int dataSize, Color color);

    /// <summary>
    /// Unload an albedo map texture.
    /// <para>
    /// Frees the underlying texture unless it is a default texture.
    /// </para>
    /// </summary>
    /// <param name="map">Albedo map to unload.</param>
    /// <seealso>R3D_UnloadAlbedoMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadAlbedoMap")]
    public static partial void UnloadAlbedoMap(AlbedoMap map);

    /// <summary>
    /// Load an emission map from file.
    /// <para>
    /// Loads an emissive texture (sRGB if enabled) and sets color + energy.
    /// </para>
    /// </summary>
    /// <param name="fileName">Path to the texture file.</param>
    /// <param name="color">Emission color.</param>
    /// <param name="energy">Emission intensity multiplier.</param>
    /// <returns>Emission map. Returns an empty map on failure.</returns>
    /// <seealso>R3D_LoadEmissionMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadEmissionMap", StringMarshalling = StringMarshalling.Utf8)]
    public static partial EmissionMap LoadEmissionMap(string fileName, Color color, float energy);

    /// <summary>
    /// Load an emission map from memory.
    /// <para>
    /// Same behavior as R3D_LoadEmissionMap(), but reads from memory.
    /// </para>
    /// </summary>
    /// <param name="fileType">Image format hint.</param>
    /// <param name="fileData">Pointer to image data.</param>
    /// <param name="dataSize">Size of image data in bytes.</param>
    /// <param name="color">Emission color.</param>
    /// <param name="energy">Emission intensity multiplier.</param>
    /// <returns>Emission map. Returns an empty map on failure.</returns>
    /// <seealso>R3D_LoadEmissionMapFromMemory</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadEmissionMapFromMemory", StringMarshalling = StringMarshalling.Utf8)]
    public static partial EmissionMap LoadEmissionMapFromMemory(string fileType, void* fileData, int dataSize, Color color, float energy);

    /// <summary>
    /// Unload an emission map texture.
    /// <para>
    /// Frees the texture unless it is a default texture.
    /// </para>
    /// </summary>
    /// <param name="map">Emission map to unload.</param>
    /// <seealso>R3D_UnloadEmissionMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadEmissionMap")]
    public static partial void UnloadEmissionMap(EmissionMap map);

    /// <summary>
    /// Load a normal map from file.
    /// <para>
    /// Uploads the texture in linear space and stores the normal scale factor.
    /// </para>
    /// </summary>
    /// <param name="fileName">Path to the texture file.</param>
    /// <param name="scale">Normal intensity multiplier.</param>
    /// <returns>Normal map. Returns an empty map on failure.</returns>
    /// <seealso>R3D_LoadNormalMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadNormalMap", StringMarshalling = StringMarshalling.Utf8)]
    public static partial NormalMap LoadNormalMap(string fileName, float scale);

    /// <summary>
    /// Load a normal map from memory.
    /// <para>
    /// Same behavior as R3D_LoadNormalMap(), but reads from memory.
    /// </para>
    /// </summary>
    /// <param name="fileType">Image format hint.</param>
    /// <param name="fileData">Pointer to image data.</param>
    /// <param name="dataSize">Size of image data in bytes.</param>
    /// <param name="scale">Normal intensity multiplier.</param>
    /// <returns>Normal map. Returns an empty map on failure.</returns>
    /// <seealso>R3D_LoadNormalMapFromMemory</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadNormalMapFromMemory", StringMarshalling = StringMarshalling.Utf8)]
    public static partial NormalMap LoadNormalMapFromMemory(string fileType, void* fileData, int dataSize, float scale);

    /// <summary>
    /// Unload a normal map texture.
    /// <para>
    /// Frees the texture unless it is a default texture.
    /// </para>
    /// </summary>
    /// <param name="map">Normal map to unload.</param>
    /// <seealso>R3D_UnloadNormalMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadNormalMap")]
    public static partial void UnloadNormalMap(NormalMap map);

    /// <summary>
    /// Load a combined ORM (Occlusion-Roughness-Metalness) map from file.
    /// <para>
    /// Uploads the texture in linear space and applies the provided multipliers.
    /// </para>
    /// </summary>
    /// <param name="fileName">Path to the ORM texture.</param>
    /// <param name="occlusion">Occlusion multiplier.</param>
    /// <param name="roughness">Roughness multiplier.</param>
    /// <param name="metalness">Metalness multiplier.</param>
    /// <returns>ORM map. Returns an empty map on failure.</returns>
    /// <seealso>R3D_LoadOrmMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadOrmMap", StringMarshalling = StringMarshalling.Utf8)]
    public static partial OrmMap LoadOrmMap(string fileName, float occlusion, float roughness, float metalness);

    /// <summary>
    /// Load a combined ORM (Occlusion-Roughness-Metalness) map from memory.
    /// <para>
    /// Same behavior as R3D_LoadOrmMap(), but reads from memory.
    /// </para>
    /// </summary>
    /// <param name="fileType">Image format hint.</param>
    /// <param name="fileData">Pointer to image data.</param>
    /// <param name="dataSize">Size of image data in bytes.</param>
    /// <param name="occlusion">Occlusion multiplier.</param>
    /// <param name="roughness">Roughness multiplier.</param>
    /// <param name="metalness">Metalness multiplier.</param>
    /// <returns>ORM map. Returns an empty map on failure.</returns>
    /// <seealso>R3D_LoadOrmMapFromMemory</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadOrmMapFromMemory", StringMarshalling = StringMarshalling.Utf8)]
    public static partial OrmMap LoadOrmMapFromMemory(string fileType, void* fileData, int dataSize, float occlusion, float roughness, float metalness);

    /// <summary>
    /// Unload an ORM map texture.
    /// <para>
    /// Frees the texture unless it is a default texture.
    /// </para>
    /// </summary>
    /// <param name="map">ORM map to unload.</param>
    /// <seealso>R3D_UnloadOrmMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadOrmMap")]
    public static partial void UnloadOrmMap(OrmMap map);

    /// <summary>
    /// Unload all map textures assigned to a R3D_Decal.
    /// <para>
    /// Frees all underlying textures in a R3D_Decal that are not a default texture.
    /// </para>
    /// </summary>
    /// <param name="decal">to unload maps from.</param>
    /// <seealso>R3D_UnloadDecalMaps</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadDecalMaps")]
    public static partial void UnloadDecalMaps(Decal decal);

    /// <summary>
    /// Create instance buffers on the GPU.
    /// </summary>
    /// <param name="capacity">Max instances.</param>
    /// <param name="flags">Attribute mask to allocate.</param>
    /// <returns>Initialized instance buffer.</returns>
    /// <seealso>R3D_LoadInstanceBuffer</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadInstanceBuffer")]
    public static partial InstanceBuffer LoadInstanceBuffer(int capacity, InstanceFlags flags);

    /// <summary>
    /// Destroy all GPU buffers owned by this instance buffer.
    /// </summary>
    /// <seealso>R3D_UnloadInstanceBuffer</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadInstanceBuffer")]
    public static partial void UnloadInstanceBuffer(InstanceBuffer buffer);

    /// <summary>
    /// Upload a contiguous range of instance data.
    /// </summary>
    /// <param name="flag">Attribute being updated (single bit).</param>
    /// <param name="offset">First instance index.</param>
    /// <param name="count">Number of instances.</param>
    /// <param name="data">Source pointer.</param>
    /// <seealso>R3D_UploadInstances</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UploadInstances")]
    public static partial void UploadInstances(InstanceBuffer buffer, InstanceFlags flag, int offset, int count, IntPtr data);

    /// <summary>
    /// Map an attribute buffer for CPU write access.
    /// </summary>
    /// <param name="flag">Attribute to map (single bit).</param>
    /// <returns>Writable pointer, or NULL on error.</returns>
    /// <seealso>R3D_MapInstances</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_MapInstances")]
    public static partial IntPtr MapInstances(InstanceBuffer buffer, InstanceFlags flag);

    /// <summary>
    /// Unmap one or more previously mapped attribute buffers.
    /// </summary>
    /// <param name="flags">Bitmask of attributes to unmap.</param>
    /// <seealso>R3D_UnmapInstances</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnmapInstances")]
    public static partial void UnmapInstances(InstanceBuffer buffer, InstanceFlags flags);

    /// <summary>
    /// Creates an empty mesh data container.
    /// <para>
    /// Allocates memory for vertex and index buffers. All allocated buffers are zero-initialized.
    /// </para>
    /// </summary>
    /// <param name="vertexCount">Number of vertices to allocate. Must be non-zero.</param>
    /// <param name="indexCount">Number of indices to allocate. May be zero. If zero, no index buffer is allocated.</param>
    /// <returns>A new R3D_MeshData instance with allocated memory.</returns>
    /// <seealso>R3D_CreateMeshData</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CreateMeshData")]
    public static partial MeshData CreateMeshData(int vertexCount, int indexCount);

    /// <summary>
    /// Releases memory used by a mesh data container.
    /// </summary>
    /// <param name="meshData">R3D_MeshData to destroy.</param>
    /// <seealso>R3D_UnloadMeshData</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadMeshData")]
    public static partial void UnloadMeshData(MeshData meshData);

    /// <summary>
    /// Check if mesh data is valid.
    /// <para>
    /// Returns true if the mesh data contains at least one vertex buffer with a positive number of vertices.
    /// </para>
    /// </summary>
    /// <param name="meshData">Mesh data to check.</param>
    /// <returns>true if valid, false otherwise.</returns>
    /// <seealso>R3D_IsMeshDataValid</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsMeshDataValid")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsMeshDataValid(MeshData meshData);

    /// <summary>
    /// Generate a quad mesh with specified dimensions, resolution, and orientation.
    /// <para>
    /// Creates a flat rectangular quad mesh with customizable facing direction. The mesh can be subdivided for higher resolution or displacement mapping. The quad is centered at the origin and oriented according to the frontDir parameter, which defines both the face direction and the surface normal.
    /// </para>
    /// </summary>
    /// <param name="width">Width of the quad along its local X axis.</param>
    /// <param name="length">Length of the quad along its local Z axis.</param>
    /// <param name="resX">Number of subdivisions along the width.</param>
    /// <param name="resZ">Number of subdivisions along the length.</param>
    /// <param name="frontDir">Direction vector defining the quad's front face and normal. This vector will be normalized internally.</param>
    /// <returns>Generated quad mesh structure with proper normals, tangents, and UVs.</returns>
    /// <seealso>R3D_GenMeshDataQuad</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataQuad")]
    public static partial MeshData GenMeshDataQuad(float width, float length, int resX, int resZ, Vector3 frontDir);

    /// <summary>
    /// Generate a plane mesh with specified dimensions and resolution.
    /// <para>
    /// Creates a flat plane mesh in the XZ plane, centered at the origin. The mesh can be subdivided for higher resolution or displacement mapping.
    /// </para>
    /// </summary>
    /// <param name="width">Width of the plane along the X axis.</param>
    /// <param name="length">Length of the plane along the Z axis.</param>
    /// <param name="resX">Number of subdivisions along the X axis.</param>
    /// <param name="resZ">Number of subdivisions along the Z axis.</param>
    /// <returns>Generated plane mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataPlane</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataPlane")]
    public static partial MeshData GenMeshDataPlane(float width, float length, int resX, int resZ);

    /// <summary>
    /// Generate a polygon mesh with specified number of sides.
    /// <para>
    /// Creates a regular polygon mesh centered at the origin in the XY plane. The polygon is generated with vertices evenly distributed around a circle.
    /// </para>
    /// </summary>
    /// <param name="sides">Number of sides for the polygon (minimum 3).</param>
    /// <param name="radius">Radius of the circumscribed circle.</param>
    /// <param name="frontDir">Direction vector defining the polygon's front face and normal. This vector will be normalized internally.</param>
    /// <returns>Generated polygon mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataPoly</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataPoly")]
    public static partial MeshData GenMeshDataPoly(int sides, float radius, Vector3 frontDir);

    /// <summary>
    /// Generate a cube mesh with specified dimensions.
    /// <para>
    /// Creates a cube mesh centered at the origin with the specified width, height, and length. Each face consists of two triangles with proper normals and texture coordinates.
    /// </para>
    /// </summary>
    /// <param name="width">Width of the cube along the X axis.</param>
    /// <param name="height">Height of the cube along the Y axis.</param>
    /// <param name="length">Length of the cube along the Z axis.</param>
    /// <returns>Generated cube mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataCube</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataCube")]
    public static partial MeshData GenMeshDataCube(float width, float height, float length);

    /// <summary>
    /// Generate a subdivided cube mesh with specified dimensions.
    /// <para>
    /// Extension of R3D_GenMeshDataCube() allowing per-axis subdivision. Each face can be tessellated along the X, Y, and Z axes according to the provided resolutions.
    /// </para>
    /// </summary>
    /// <param name="width">Width of the cube along the X axis.</param>
    /// <param name="height">Height of the cube along the Y axis.</param>
    /// <param name="length">Length of the cube along the Z axis.</param>
    /// <param name="resX">Number of subdivisions along the X axis.</param>
    /// <param name="resY">Number of subdivisions along the Y axis.</param>
    /// <param name="resZ">Number of subdivisions along the Z axis.</param>
    /// <returns>Generated cube mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataCubeEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataCubeEx")]
    public static partial MeshData GenMeshDataCubeEx(float width, float height, float length, int resX, int resY, int resZ);

    /// <summary>
    /// Generate a sphere mesh with specified parameters.
    /// <para>
    /// Creates a UV sphere mesh centered at the origin using latitude-longitude subdivision. Higher ring and slice counts produce smoother spheres but with more vertices.
    /// </para>
    /// </summary>
    /// <param name="radius">Radius of the sphere.</param>
    /// <param name="rings">Number of horizontal rings (latitude divisions).</param>
    /// <param name="slices">Number of vertical slices (longitude divisions).</param>
    /// <returns>Generated sphere mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataSphere</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataSphere")]
    public static partial MeshData GenMeshDataSphere(float radius, int rings, int slices);

    /// <summary>
    /// Generate a hemisphere mesh with specified parameters.
    /// <para>
    /// Creates a half-sphere mesh (dome) centered at the origin, extending upward in the Y axis. Uses the same UV sphere generation technique as R3D_GenMeshSphere but only the upper half.
    /// </para>
    /// </summary>
    /// <param name="radius">Radius of the hemisphere.</param>
    /// <param name="rings">Number of horizontal rings (latitude divisions).</param>
    /// <param name="slices">Number of vertical slices (longitude divisions).</param>
    /// <returns>Generated hemisphere mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataHemiSphere</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataHemiSphere")]
    public static partial MeshData GenMeshDataHemiSphere(float radius, int rings, int slices);

    /// <summary>
    /// Generate a cylinder mesh with specified parameters.
    /// <para>
    /// Creates a mesh centered at the origin, extending along the Y axis. The mesh includes top and bottom caps and smooth side surfaces. A cone is produced when bottomRadius and topRadius differ.
    /// </para>
    /// </summary>
    /// <param name="bottomRadius">Radius of the bottom cap.</param>
    /// <param name="topRadius">Radius of the top cap.</param>
    /// <param name="height">Height of the shape along the Y axis.</param>
    /// <param name="slices">Number of radial subdivisions around the shape.</param>
    /// <returns>Generated mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataCylinder</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataCylinder")]
    public static partial MeshData GenMeshDataCylinder(float bottomRadius, float topRadius, float height, int slices);

    /// <summary>
    /// Generate a torus mesh with specified parameters.
    /// <para>
    /// Creates a torus (donut shape) mesh centered at the origin in the XZ plane. The torus is defined by a major radius (distance from center to tube center) and a minor radius (tube thickness).
    /// </para>
    /// </summary>
    /// <param name="radius">Major radius of the torus (distance from center to tube center).</param>
    /// <param name="size">Minor radius of the torus (tube thickness/radius).</param>
    /// <param name="radSeg">Number of segments around the major radius.</param>
    /// <param name="sides">Number of sides around the tube cross-section.</param>
    /// <returns>Generated torus mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataTorus</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataTorus")]
    public static partial MeshData GenMeshDataTorus(float radius, float size, int radSeg, int sides);

    /// <summary>
    /// Generate a trefoil knot mesh with specified parameters.
    /// <para>
    /// Creates a trefoil knot mesh, which is a mathematical knot shape. Similar to a torus but with a twisted, knotted topology.
    /// </para>
    /// </summary>
    /// <param name="radius">Major radius of the knot.</param>
    /// <param name="size">Minor radius (tube thickness) of the knot.</param>
    /// <param name="radSeg">Number of segments around the major radius.</param>
    /// <param name="sides">Number of sides around the tube cross-section.</param>
    /// <returns>Generated trefoil knot mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataKnot</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataKnot")]
    public static partial MeshData GenMeshDataKnot(float radius, float size, int radSeg, int sides);

    /// <summary>
    /// Generate a terrain mesh from a heightmap image.
    /// <para>
    /// Creates a terrain mesh by interpreting the brightness values of a heightmap image as height values. The resulting mesh represents a 3D terrain surface.
    /// </para>
    /// </summary>
    /// <param name="heightmap">Image containing height data (grayscale values represent elevation).</param>
    /// <param name="size">3D vector defining the terrain dimensions (width, max height, depth).</param>
    /// <returns>Generated heightmap terrain mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataHeightmap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataHeightmap")]
    public static partial MeshData GenMeshDataHeightmap(Image heightmap, Vector3 size);

    /// <summary>
    /// Generate a voxel-style mesh from a cubicmap image.
    /// <para>
    /// Creates a mesh composed of cubes based on a cubicmap image, where each pixel represents the presence or absence of a cube at that position. Useful for creating voxel-based or block-based geometry.
    /// </para>
    /// </summary>
    /// <param name="cubicmap">Image where pixel values determine cube placement.</param>
    /// <param name="cubeSize">3D vector defining the size of each individual cube.</param>
    /// <returns>Generated cubicmap mesh structure.</returns>
    /// <seealso>R3D_GenMeshDataCubicmap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataCubicmap")]
    public static partial MeshData GenMeshDataCubicmap(Image cubicmap, Vector3 cubeSize);

    /// <summary>
    /// Creates a deep copy of an existing mesh data container.
    /// </summary>
    /// <param name="meshData">Source mesh data to duplicate.</param>
    /// <returns>A new R3D_MeshData containing a copy of the source data.</returns>
    /// <seealso>R3D_DuplicateMeshData</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DuplicateMeshData")]
    public static partial MeshData DuplicateMeshData(MeshData meshData);

    /// <summary>
    /// Merges two mesh data containers into a single one.
    /// </summary>
    /// <param name="a">First mesh data.</param>
    /// <param name="b">Second mesh data.</param>
    /// <returns>A new R3D_MeshData containing the merged geometry.</returns>
    /// <seealso>R3D_MergeMeshData</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_MergeMeshData")]
    public static partial MeshData MergeMeshData(MeshData a, MeshData b);

    /// <summary>
    /// Translates all vertices by a given offset.
    /// </summary>
    /// <param name="meshData">Mesh data to modify.</param>
    /// <param name="translation">Offset to apply to all vertex positions.</param>
    /// <seealso>R3D_TranslateMeshData</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_TranslateMeshData")]
    public static partial void TranslateMeshData(ref MeshData meshData, Vector3 translation);

    /// <summary>
    /// Rotates all vertices using a quaternion.
    /// </summary>
    /// <param name="meshData">Mesh data to modify.</param>
    /// <param name="rotation">Quaternion representing the rotation.</param>
    /// <seealso>R3D_RotateMeshData</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_RotateMeshData")]
    public static partial void RotateMeshData(ref MeshData meshData, Quaternion rotation);

    /// <summary>
    /// Scales all vertices by given factors.
    /// </summary>
    /// <param name="meshData">Mesh data to modify.</param>
    /// <param name="scale">Scaling factors for each axis.</param>
    /// <seealso>R3D_ScaleMeshData</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_ScaleMeshData")]
    public static partial void ScaleMeshData(ref MeshData meshData, Vector3 scale);

    /// <summary>
    /// Generates planar UV coordinates.
    /// </summary>
    /// <param name="meshData">Mesh data to modify.</param>
    /// <param name="uvScale">Scaling factors for UV coordinates.</param>
    /// <param name="axis">Axis along which to project the planar mapping.</param>
    /// <seealso>R3D_GenMeshDataUVsPlanar</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataUVsPlanar")]
    public static partial void GenMeshDataUVsPlanar(ref MeshData meshData, Vector2 uvScale, Vector3 axis);

    /// <summary>
    /// Generates spherical UV coordinates.
    /// </summary>
    /// <param name="meshData">Mesh data to modify.</param>
    /// <seealso>R3D_GenMeshDataUVsSpherical</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataUVsSpherical")]
    public static partial void GenMeshDataUVsSpherical(ref MeshData meshData);

    /// <summary>
    /// Generates cylindrical UV coordinates.
    /// </summary>
    /// <param name="meshData">Mesh data to modify.</param>
    /// <seealso>R3D_GenMeshDataUVsCylindrical</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataUVsCylindrical")]
    public static partial void GenMeshDataUVsCylindrical(ref MeshData meshData);

    /// <summary>
    /// Computes vertex normals from triangle geometry.
    /// </summary>
    /// <param name="meshData">Mesh data to modify.</param>
    /// <seealso>R3D_GenMeshDataNormals</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataNormals")]
    public static partial void GenMeshDataNormals(ref MeshData meshData);

    /// <summary>
    /// Computes vertex tangents based on existing normals and UVs.
    /// </summary>
    /// <param name="meshData">Mesh data to modify.</param>
    /// <seealso>R3D_GenMeshDataTangents</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshDataTangents")]
    public static partial void GenMeshDataTangents(ref MeshData meshData);

    /// <summary>
    /// Calculates the axis-aligned bounding box of the mesh.
    /// </summary>
    /// <param name="meshData">Mesh data to analyze.</param>
    /// <returns>The computed bounding box.</returns>
    /// <seealso>R3D_CalculateMeshDataBoundingBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CalculateMeshDataBoundingBox")]
    public static partial BoundingBox CalculateMeshDataBoundingBox(MeshData meshData);

    /// <summary>
    /// Creates a 3D mesh from CPU-side mesh data.
    /// </summary>
    /// <param name="type">Primitive type used to interpret vertex data.</param>
    /// <param name="data">R3D_MeshData containing vertices and indices (cannot be NULL).</param>
    /// <param name="aabb">Optional pointer to a bounding box. If NULL, it will be computed automatically.</param>
    /// <param name="usage">Hint on how the mesh will be used.</param>
    /// <returns>Created R3D_Mesh.</returns>
    /// <remarks>
    /// The function copies all vertex and index data into GPU buffers.
    /// </remarks>
    /// <seealso>R3D_LoadMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadMesh")]
    public static partial Mesh LoadMesh(PrimitiveType type, MeshData data, BoundingBox* aabb, MeshUsage usage);

    /// <summary>
    /// Destroys a 3D mesh and frees its resources.
    /// </summary>
    /// <param name="mesh">R3D_Mesh to destroy.</param>
    /// <seealso>R3D_UnloadMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadMesh")]
    public static partial void UnloadMesh(Mesh mesh);

    /// <summary>
    /// Check if a mesh is valid for rendering.
    /// <para>
    /// Returns true if the mesh has a valid VAO and VBO.
    /// </para>
    /// </summary>
    /// <param name="mesh">The mesh to check.</param>
    /// <returns>true if valid, false otherwise.</returns>
    /// <seealso>R3D_IsMeshValid</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsMeshValid")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsMeshValid(Mesh mesh);

    /// <summary>
    /// Generate a quad mesh with orientation.
    /// </summary>
    /// <param name="width">Width along local X axis.</param>
    /// <param name="length">Length along local Z axis.</param>
    /// <param name="resX">Subdivisions along width.</param>
    /// <param name="resZ">Subdivisions along length.</param>
    /// <param name="frontDir">Direction vector for the quad's front face.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshQuad</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshQuad")]
    public static partial Mesh GenMeshQuad(float width, float length, int resX, int resZ, Vector3 frontDir);

    /// <summary>
    /// Generate a plane mesh.
    /// </summary>
    /// <param name="width">Width along X axis.</param>
    /// <param name="length">Length along Z axis.</param>
    /// <param name="resX">Subdivisions along X axis.</param>
    /// <param name="resZ">Subdivisions along Z axis.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshPlane</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshPlane")]
    public static partial Mesh GenMeshPlane(float width, float length, int resX, int resZ);

    /// <summary>
    /// Generate a polygon mesh.
    /// </summary>
    /// <param name="sides">Number of sides (min 3).</param>
    /// <param name="radius">Radius of the polygon.</param>
    /// <param name="frontDir">Direction vector for the polygon's front face.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshPoly</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshPoly")]
    public static partial Mesh GenMeshPoly(int sides, float radius, Vector3 frontDir);

    /// <summary>
    /// Generate a cube mesh.
    /// </summary>
    /// <param name="width">Width along X axis.</param>
    /// <param name="height">Height along Y axis.</param>
    /// <param name="length">Length along Z axis.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshCube</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshCube")]
    public static partial Mesh GenMeshCube(float width, float height, float length);

    /// <summary>
    /// Generate a subdivided cube mesh.
    /// </summary>
    /// <param name="width">Width along X axis.</param>
    /// <param name="height">Height along Y axis.</param>
    /// <param name="length">Length along Z axis.</param>
    /// <param name="resX">Subdivisions along X axis.</param>
    /// <param name="resY">Subdivisions along Y axis.</param>
    /// <param name="resZ">Subdivisions along Z axis.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshCubeEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshCubeEx")]
    public static partial Mesh GenMeshCubeEx(float width, float height, float length, int resX, int resY, int resZ);

    /// <summary>
    /// Generate a sphere mesh.
    /// </summary>
    /// <param name="radius">Sphere radius.</param>
    /// <param name="rings">Number of latitude divisions.</param>
    /// <param name="slices">Number of longitude divisions.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshSphere</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshSphere")]
    public static partial Mesh GenMeshSphere(float radius, int rings, int slices);

    /// <summary>
    /// Generate a hemisphere mesh.
    /// </summary>
    /// <param name="radius">Hemisphere radius.</param>
    /// <param name="rings">Number of latitude divisions.</param>
    /// <param name="slices">Number of longitude divisions.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshHemiSphere</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshHemiSphere")]
    public static partial Mesh GenMeshHemiSphere(float radius, int rings, int slices);

    /// <summary>
    /// Generate a cylinder mesh.
    /// </summary>
    /// <param name="bottomRadius">Bottom radius.</param>
    /// <param name="topRadius">Top radius.</param>
    /// <param name="height">Height along Y axis.</param>
    /// <param name="slices">Radial subdivisions.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshCylinder</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshCylinder")]
    public static partial Mesh GenMeshCylinder(float bottomRadius, float topRadius, float height, int slices);

    /// <summary>
    /// Generate a torus mesh.
    /// </summary>
    /// <param name="radius">Major radius (center to tube).</param>
    /// <param name="size">Minor radius (tube thickness).</param>
    /// <param name="radSeg">Segments around major radius.</param>
    /// <param name="sides">Sides around tube cross-section.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshTorus</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshTorus")]
    public static partial Mesh GenMeshTorus(float radius, float size, int radSeg, int sides);

    /// <summary>
    /// Generate a trefoil knot mesh.
    /// </summary>
    /// <param name="radius">Major radius.</param>
    /// <param name="size">Minor radius.</param>
    /// <param name="radSeg">Segments around major radius.</param>
    /// <param name="sides">Sides around tube cross-section.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshKnot</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshKnot")]
    public static partial Mesh GenMeshKnot(float radius, float size, int radSeg, int sides);

    /// <summary>
    /// Generate a heightmap terrain mesh.
    /// </summary>
    /// <param name="heightmap">Heightmap image.</param>
    /// <param name="size">3D dimensions of terrain.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshHeightmap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshHeightmap")]
    public static partial Mesh GenMeshHeightmap(Image heightmap, Vector3 size);

    /// <summary>
    /// Generate a cubicmap voxel mesh.
    /// </summary>
    /// <param name="cubicmap">Cubicmap image.</param>
    /// <param name="cubeSize">Size of each cube.</param>
    /// <returns>Mesh ready for rendering.</returns>
    /// <seealso>R3D_GenMeshCubicmap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GenMeshCubicmap")]
    public static partial Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize);

    /// <summary>
    /// Upload a mesh data on the GPU.
    /// <para>
    /// This function uploads a mesh's vertex and optional index data to the GPU.
    /// </para>
    /// <para>
    /// If `aabb` is provided, it will be used as the mesh's bounding box; if null, the bounding box is automatically recalculated from the vertex data.
    /// </para>
    /// </summary>
    /// <param name="mesh">Pointer to the mesh structure to update.</param>
    /// <param name="data">Mesh data (vertices and indices) to upload.</param>
    /// <param name="aabb">Optional bounding box; if null, it is recalculated automatically.</param>
    /// <returns>Returns true if the update is successful, false otherwise.</returns>
    /// <seealso>R3D_UpdateMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UpdateMesh")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool UpdateMesh(ref Mesh mesh, MeshData data, BoundingBox* aabb);

    /// <summary>
    /// Load a 3D model from a file.
    /// <para>
    /// Loads a 3D model from the specified file path. Supports various 3D file formats and automatically parses meshes, materials, and texture references.
    /// </para>
    /// </summary>
    /// <param name="filePath">Path to the 3D model file to load.</param>
    /// <returns>Loaded model structure containing meshes and materials.</returns>
    /// <seealso>R3D_LoadModel</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadModel", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Model LoadModel(string filePath);

    /// <summary>
    /// Load a 3D model from a file with import flags.
    /// <para>
    /// Extended version of R3D_LoadModel() allowing control over the import process through additional flags.
    /// </para>
    /// </summary>
    /// <param name="filePath">Path to the 3D model file to load.</param>
    /// <param name="flags">Importer behavior flags.</param>
    /// <returns>Loaded model structure containing meshes and materials.</returns>
    /// <seealso>R3D_LoadModelEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadModelEx", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Model LoadModelEx(string filePath, ImportFlags flags);

    /// <summary>
    /// Load a 3D model from memory buffer.
    /// <para>
    /// Loads a 3D model from a memory buffer containing the file data. Useful for loading models from embedded resources or network streams.
    /// </para>
    /// </summary>
    /// <param name="data">Pointer to the memory buffer containing the model data.</param>
    /// <param name="size">Size of the data buffer in bytes.</param>
    /// <param name="hint">Hint on the model format (can be NULL).</param>
    /// <returns>Loaded model structure containing meshes and materials.</returns>
    /// <remarks>
    /// External dependencies (e.g., textures or linked resources) are not supported. The model data must be fully self-contained. Use embedded formats like .glb to ensure compatibility.
    /// </remarks>
    /// <seealso>R3D_LoadModelFromMemory</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadModelFromMemory", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Model LoadModelFromMemory(void* data, uint size, string hint);

    /// <summary>
    /// Load a 3D model from a memory buffer with import flags.
    /// <para>
    /// Extended version of R3D_LoadModelFromMemory() allowing control over the import process through additional flags.
    /// </para>
    /// </summary>
    /// <param name="data">Pointer to the memory buffer containing the model data.</param>
    /// <param name="size">Size of the data buffer in bytes.</param>
    /// <param name="hint">Hint on the model format (can be NULL).</param>
    /// <param name="flags">Importer behavior flags.</param>
    /// <returns>Loaded model structure containing meshes and materials.</returns>
    /// <remarks>
    /// External dependencies (e.g., textures or linked resources) are not supported. The model data must be fully self-contained.
    /// </remarks>
    /// <seealso>R3D_LoadModelFromMemoryEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadModelFromMemoryEx", StringMarshalling = StringMarshalling.Utf8)]
    public static partial Model LoadModelFromMemoryEx(void* data, uint size, string hint, ImportFlags flags);

    /// <summary>
    /// Load a 3D model from an existing importer.
    /// <para>
    /// Creates a model from a previously loaded importer instance. This avoids re-importing the source file.
    /// </para>
    /// </summary>
    /// <param name="importer">Importer instance to extract the model from.</param>
    /// <returns>Loaded model structure containing meshes and materials.</returns>
    /// <seealso>R3D_LoadModelFromImporter</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LoadModelFromImporter")]
    public static partial Model LoadModelFromImporter(Importer* importer);

    /// <summary>
    /// Unload a model and optionally its materials.
    /// <para>
    /// Frees all memory associated with a model, including its meshes. Materials can be optionally unloaded as well.
    /// </para>
    /// </summary>
    /// <param name="model">The model to be unloaded.</param>
    /// <param name="unloadMaterials">If true, also unloads all materials associated with the model. Set to false if textures are still being used elsewhere to avoid freeing shared resources.</param>
    /// <seealso>R3D_UnloadModel</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UnloadModel")]
    public static partial void UnloadModel(Model model, [MarshalAs(UnmanagedType.I1)] bool unloadMaterials);

    /// <summary>
    /// Begins a rendering session using the given camera.
    /// <para>
    /// Rendering output is directed to the default framebuffer.
    /// </para>
    /// </summary>
    /// <param name="camera">Camera used to render the scene.</param>
    /// <seealso>R3D_Begin</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_Begin")]
    public static partial void Begin(Camera3D camera);

    /// <summary>
    /// Begins a rendering session with a custom render target.
    /// <para>
    /// If the render target is invalid (ID = 0), rendering goes to the screen.
    /// </para>
    /// </summary>
    /// <param name="target">Render texture to render into.</param>
    /// <param name="camera">Camera used to render the scene.</param>
    /// <seealso>R3D_BeginEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_BeginEx")]
    public static partial void BeginEx(RenderTexture2D target, Camera3D camera);

    /// <summary>
    /// Ends the current rendering session.
    /// <para>
    /// This function is the one that actually performs the full rendering of the described scene. It carries out culling, sorting, shadow rendering, scene rendering, and screen / post-processing effects.
    /// </para>
    /// </summary>
    /// <seealso>R3D_End</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_End")]
    public static partial void End();

    /// <summary>
    /// Begins a clustered draw pass.
    /// <para>
    /// All draw calls submitted in this pass are first tested against the cluster AABB. If the cluster fails the scene/shadow frustum test, none of the contained objects are tested or drawn.
    /// </para>
    /// </summary>
    /// <param name="aabb">Bounding box used as the cluster-level frustum test.</param>
    /// <seealso>R3D_BeginCluster</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_BeginCluster")]
    public static partial void BeginCluster(BoundingBox aabb);

    /// <summary>
    /// Ends the current clustered draw pass.
    /// <para>
    /// Stops submitting draw calls to the active cluster.
    /// </para>
    /// </summary>
    /// <seealso>R3D_EndCluster</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_EndCluster")]
    public static partial void EndCluster();

    /// <summary>
    /// Queues a mesh draw command with position and uniform scale.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawMesh")]
    public static partial void DrawMesh(Mesh mesh, Material material, Vector3 position, float scale);

    /// <summary>
    /// Queues a mesh draw command with position, rotation and non-uniform scale.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawMeshEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawMeshEx")]
    public static partial void DrawMeshEx(Mesh mesh, Material material, Vector3 position, Quaternion rotation, Vector3 scale);

    /// <summary>
    /// Queues a mesh draw command using a full transform matrix.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawMeshPro</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawMeshPro")]
    public static partial void DrawMeshPro(Mesh mesh, Material material, Matrix4x4 transform);

    /// <summary>
    /// Queues an instanced mesh draw command.
    /// <para>
    /// Draws multiple instances using the provided instance buffer.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawMeshInstanced</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawMeshInstanced")]
    public static partial void DrawMeshInstanced(Mesh mesh, Material material, InstanceBuffer instances, int count);

    /// <summary>
    /// Queues an instanced mesh draw command with an additional transform.
    /// <para>
    /// The transform is applied to all instances.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawMeshInstancedEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawMeshInstancedEx")]
    public static partial void DrawMeshInstancedEx(Mesh mesh, Material material, InstanceBuffer instances, int count, Matrix4x4 transform);

    /// <summary>
    /// Queues a model draw command with position and uniform scale.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawModel</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawModel")]
    public static partial void DrawModel(Model model, Vector3 position, float scale);

    /// <summary>
    /// Queues a model draw command with position, rotation and non-uniform scale.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawModelEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawModelEx")]
    public static partial void DrawModelEx(Model model, Vector3 position, Quaternion rotation, Vector3 scale);

    /// <summary>
    /// Queues a model draw command using a full transform matrix.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawModelPro</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawModelPro")]
    public static partial void DrawModelPro(Model model, Matrix4x4 transform);

    /// <summary>
    /// Queues an instanced model draw command.
    /// <para>
    /// Draws multiple instances using the provided instance buffer.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawModelInstanced</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawModelInstanced")]
    public static partial void DrawModelInstanced(Model model, InstanceBuffer instances, int count);

    /// <summary>
    /// Queues an instanced model draw command with an additional transform.
    /// <para>
    /// The transform is applied to all instances.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawModelInstancedEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawModelInstancedEx")]
    public static partial void DrawModelInstancedEx(Model model, InstanceBuffer instances, int count, Matrix4x4 transform);

    /// <summary>
    /// Queues an animated model draw command.
    /// <para>
    /// Uses the provided animation player to compute the pose.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawAnimatedModel</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawAnimatedModel")]
    public static partial void DrawAnimatedModel(Model model, AnimationPlayer player, Vector3 position, float scale);

    /// <summary>
    /// Queues an animated model draw command with position, rotation and non-uniform scale.
    /// <para>
    /// Uses the provided animation player to compute the pose.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawAnimatedModelEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawAnimatedModelEx")]
    public static partial void DrawAnimatedModelEx(Model model, AnimationPlayer player, Vector3 position, Quaternion rotation, Vector3 scale);

    /// <summary>
    /// Queues an animated model draw command using a full transform matrix.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawAnimatedModelPro</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawAnimatedModelPro")]
    public static partial void DrawAnimatedModelPro(Model model, AnimationPlayer player, Matrix4x4 transform);

    /// <summary>
    /// Queues an instanced animated model draw command.
    /// <para>
    /// Draws multiple animated instances using the provided instance buffer.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawAnimatedModelInstanced</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawAnimatedModelInstanced")]
    public static partial void DrawAnimatedModelInstanced(Model model, AnimationPlayer player, InstanceBuffer instances, int count);

    /// <summary>
    /// Queues an instanced animated model draw command with an additional transform.
    /// <para>
    /// The transform is applied to all instances.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawAnimatedModelInstancedEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawAnimatedModelInstancedEx")]
    public static partial void DrawAnimatedModelInstancedEx(Model model, AnimationPlayer player, InstanceBuffer instances, int count, Matrix4x4 transform);

    /// <summary>
    /// Queues a decal draw command with position and uniform scale.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawDecal</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawDecal")]
    public static partial void DrawDecal(Decal decal, Vector3 position, float scale);

    /// <summary>
    /// Queues a decal draw command with position, rotation and non-uniform scale.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawDecalEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawDecalEx")]
    public static partial void DrawDecalEx(Decal decal, Vector3 position, Quaternion rotation, Vector3 scale);

    /// <summary>
    /// Queues a decal draw command using a full transform matrix.
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawDecalPro</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawDecalPro")]
    public static partial void DrawDecalPro(Decal decal, Matrix4x4 transform);

    /// <summary>
    /// Queues an instanced decal draw command.
    /// <para>
    /// Draws multiple instances using the provided instance buffer.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawDecalInstanced</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawDecalInstanced")]
    public static partial void DrawDecalInstanced(Decal decal, InstanceBuffer instances, int count);

    /// <summary>
    /// Queues an instanced decal draw command with an additional transform.
    /// <para>
    /// The transform is applied to all instances.
    /// </para>
    /// <para>
    /// The command is executed during R3D_End().
    /// </para>
    /// </summary>
    /// <seealso>R3D_DrawDecalInstancedEx</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawDecalInstancedEx")]
    public static partial void DrawDecalInstancedEx(Decal decal, InstanceBuffer instances, int count, Matrix4x4 transform);

    /// <summary>
    /// Retrieves a pointer to the current environment configuration.
    /// <para>
    /// Provides direct read/write access to environment settings. Modifications take effect immediately.
    /// </para>
    /// </summary>
    /// <returns>Pointer to the active R3D_Environment structure</returns>
    /// <seealso>R3D_GetEnvironment</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetEnvironment")]
    public static partial Environment* GetEnvironment();

    /// <summary>
    /// Replaces the entire environment configuration.
    /// <para>
    /// Copies all settings from the provided structure to the active environment. Useful for switching between presets or restoring saved states.
    /// </para>
    /// </summary>
    /// <param name="env">Pointer to the R3D_Environment structure to copy from</param>
    /// <seealso>R3D_SetEnvironment</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetEnvironment")]
    public static partial void SetEnvironment(Environment* env);

    /// <summary>
    /// Creates a new light of the specified type.
    /// <para>
    /// This function creates a light of the given type. The light must be destroyed manually when no longer needed by calling `R3D_DestroyLight`.
    /// </para>
    /// </summary>
    /// <param name="type">The type of light to create (directional, spot or omni-directional).</param>
    /// <returns>The ID of the created light.</returns>
    /// <seealso>R3D_CreateLight</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CreateLight")]
    public static partial Light CreateLight(LightType type);

    /// <summary>
    /// Destroys the specified light.
    /// <para>
    /// This function deallocates the resources associated with the light and makes the light ID invalid. It must be called after the light is no longer needed.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light to destroy.</param>
    /// <seealso>R3D_DestroyLight</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DestroyLight")]
    public static partial void DestroyLight(Light id);

    /// <summary>
    /// Checks if a light exists.
    /// <para>
    /// This function checks if the specified light ID is valid and if the light exists.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light to check.</param>
    /// <returns>True if the light exists, false otherwise.</returns>
    /// <seealso>R3D_IsLightExist</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsLightExist")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsLightExist(Light id);

    /// <summary>
    /// Gets the type of a light.
    /// <para>
    /// This function returns the type of the specified light (directional, spot or omni-directional).
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The type of the light.</returns>
    /// <seealso>R3D_GetLightType</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightType")]
    public static partial LightType GetLightType(Light id);

    /// <summary>
    /// Checks if a light is active.
    /// <para>
    /// This function checks whether the specified light is currently active (enabled or disabled).
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light to check.</param>
    /// <returns>True if the light is active, false otherwise.</returns>
    /// <seealso>R3D_IsLightActive</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsLightActive")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsLightActive(Light id);

    /// <summary>
    /// Toggles the state of a light (active or inactive).
    /// <para>
    /// This function toggles the state of the specified light, turning it on if it is off, or off if it is on.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light to toggle.</param>
    /// <seealso>R3D_ToggleLight</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_ToggleLight")]
    public static partial void ToggleLight(Light id);

    /// <summary>
    /// Sets the active state of a light.
    /// <para>
    /// This function allows manually turning a light on or off by specifying its active state.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light to set the active state for.</param>
    /// <param name="active">True to activate the light, false to deactivate it.</param>
    /// <seealso>R3D_SetLightActive</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightActive")]
    public static partial void SetLightActive(Light id, [MarshalAs(UnmanagedType.I1)] bool active);

    /// <summary>
    /// Gets the color of a light.
    /// <para>
    /// This function retrieves the color of the specified light as a `Color` structure.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The color of the light as a `Color` structure.</returns>
    /// <seealso>R3D_GetLightColor</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightColor")]
    public static partial Color GetLightColor(Light id);

    /// <summary>
    /// Gets the color of a light as a `Vector3`.
    /// <para>
    /// This function retrieves the color of the specified light as a `Vector3`, where each component (x, y, z) represents the RGB values of the light.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The color of the light as a `Vector3`.</returns>
    /// <seealso>R3D_GetLightColorV</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightColorV")]
    public static partial Vector3 GetLightColorV(Light id);

    /// <summary>
    /// Sets the color of a light.
    /// <para>
    /// This function sets the color of the specified light using a `Color` structure.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="color">The new color to set for the light.</param>
    /// <seealso>R3D_SetLightColor</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightColor")]
    public static partial void SetLightColor(Light id, Color color);

    /// <summary>
    /// Sets the color of a light using a `Vector3`.
    /// <para>
    /// This function sets the color of the specified light using a `Vector3`, where each component (x, y, z) represents the RGB values of the light.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="color">The new color to set for the light as a `Vector3`.</param>
    /// <seealso>R3D_SetLightColorV</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightColorV")]
    public static partial void SetLightColorV(Light id, Vector3 color);

    /// <summary>
    /// Gets the position of a light.
    /// <para>
    /// This function retrieves the position of the specified light. Only applicable to spot lights or omni-lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The position of the light as a `Vector3`.</returns>
    /// <seealso>R3D_GetLightPosition</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightPosition")]
    public static partial Vector3 GetLightPosition(Light id);

    /// <summary>
    /// Sets the position of a light.
    /// <para>
    /// This function sets the position of the specified light. Only applicable to spot lights or omni-lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="position">The new position to set for the light.</param>
    /// <remarks>
    /// Has no effect for directional lights. If called on a directional light, a warning will be logged.
    /// </remarks>
    /// <seealso>R3D_SetLightPosition</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightPosition")]
    public static partial void SetLightPosition(Light id, Vector3 position);

    /// <summary>
    /// Gets the direction of a light.
    /// <para>
    /// This function retrieves the direction of the specified light. Only applicable to directional lights or spot lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The direction of the light as a `Vector3`.</returns>
    /// <seealso>R3D_GetLightDirection</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightDirection")]
    public static partial Vector3 GetLightDirection(Light id);

    /// <summary>
    /// Sets the direction of a light.
    /// <para>
    /// This function sets the direction of the specified light. Only applicable to directional lights or spot lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="direction">The new direction to set for the light. The vector is automatically normalized.</param>
    /// <remarks>
    /// Has no effect for omni-directional lights. If called on an omni-directional light, a warning will be logged.
    /// </remarks>
    /// <seealso>R3D_SetLightDirection</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightDirection")]
    public static partial void SetLightDirection(Light id, Vector3 direction);

    /// <summary>
    /// Sets the position and direction of a light to look at a target point.
    /// <para>
    /// This function sets both the position and the direction of the specified light, causing it to &quot;look at&quot; a given target point.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="position">The position to set for the light.</param>
    /// <param name="target">The point the light should look at.</param>
    /// <remarks>
    /// <list type="bullet">
    /// <item><description>For directional lights, only the direction is updated (position is ignored).</description></item>
    /// <item><description>For omni-directional lights, only the position is updated (direction is not calculated).</description></item>
    /// <item><description>For spot lights, both position and direction are set accordingly.</description></item>
    /// <item><description>This function does **not** emit any warning or log message.</description></item>
    /// </list>
    /// </remarks>
    /// <seealso>R3D_LightLookAt</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_LightLookAt")]
    public static partial void LightLookAt(Light id, Vector3 position, Vector3 target);

    /// <summary>
    /// Gets the energy level of a light.
    /// <para>
    /// This function retrieves the energy level (intensity) of the specified light. Energy typically affects the brightness of the light.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The energy level of the light.</returns>
    /// <seealso>R3D_GetLightEnergy</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightEnergy")]
    public static partial float GetLightEnergy(Light id);

    /// <summary>
    /// Sets the energy level of a light.
    /// <para>
    /// This function sets the energy (intensity) of the specified light. A higher energy value will result in a brighter light.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="energy">The new energy value to set for the light.</param>
    /// <seealso>R3D_SetLightEnergy</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightEnergy")]
    public static partial void SetLightEnergy(Light id, float energy);

    /// <summary>
    /// Gets the specular intensity of a light.
    /// <para>
    /// This function retrieves the current specular intensity of the specified light. Specular intensity affects how shiny surfaces appear when reflecting the light.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The current specular intensity of the light.</returns>
    /// <seealso>R3D_GetLightSpecular</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightSpecular")]
    public static partial float GetLightSpecular(Light id);

    /// <summary>
    /// Sets the specular intensity of a light.
    /// <para>
    /// This function sets the specular intensity of the specified light. Higher specular values result in stronger and sharper highlights on reflective surfaces.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="specular">The new specular intensity value to set for the light.</param>
    /// <seealso>R3D_SetLightSpecular</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightSpecular")]
    public static partial void SetLightSpecular(Light id, float specular);

    /// <summary>
    /// Gets the range of a light.
    /// <para>
    /// This function retrieves the range of the specified light, which determines how far the light can affect. Only applicable to spot lights or omni-lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The range of the light.</returns>
    /// <seealso>R3D_GetLightRange</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightRange")]
    public static partial float GetLightRange(Light id);

    /// <summary>
    /// Sets the range parameter of a light.
    /// <para>
    /// For spot and omni lights, this defines the maximum illumination distance. For directional lights, this defines the shadow rendering radius around the camera.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="range">The range value to apply.</param>
    /// <seealso>R3D_SetLightRange</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightRange")]
    public static partial void SetLightRange(Light id, float range);

    /// <summary>
    /// Gets the attenuation factor of a light.
    /// <para>
    /// This function retrieves the attenuation factor of the specified light. Attenuation controls how the intensity of a light decreases with distance. Only applicable to spot lights or omni-lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The attenuation factor of the light.</returns>
    /// <seealso>R3D_GetLightAttenuation</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightAttenuation")]
    public static partial float GetLightAttenuation(Light id);

    /// <summary>
    /// Sets the attenuation factor of a light.
    /// <para>
    /// This function sets the attenuation factor of the specified light. A higher attenuation value causes the light to lose intensity more quickly as the distance increases. For a realistic effect, an attenuation factor of 2.0f is typically used. Only applicable to spot lights or omni-lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="attenuation">The new attenuation factor to set for the light.</param>
    /// <seealso>R3D_SetLightAttenuation</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightAttenuation")]
    public static partial void SetLightAttenuation(Light id, float attenuation);

    /// <summary>
    /// Gets the inner cutoff angle of a spotlight.
    /// <para>
    /// This function retrieves the inner cutoff angle of a spotlight. The inner cutoff defines the cone of light where the light is at full intensity.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The inner cutoff angle in degrees of the spotlight.</returns>
    /// <seealso>R3D_GetLightInnerCutOff</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightInnerCutOff")]
    public static partial float GetLightInnerCutOff(Light id);

    /// <summary>
    /// Sets the inner cutoff angle of a spotlight.
    /// <para>
    /// This function sets the inner cutoff angle of a spotlight. The inner cutoff angle defines the cone where the light is at full intensity. Anything outside this cone starts to fade.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="degrees">The new inner cutoff angle in degrees.</param>
    /// <seealso>R3D_SetLightInnerCutOff</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightInnerCutOff")]
    public static partial void SetLightInnerCutOff(Light id, float degrees);

    /// <summary>
    /// Gets the outer cutoff angle of a spotlight.
    /// <para>
    /// This function retrieves the outer cutoff angle of a spotlight. The outer cutoff defines the outer boundary of the light's cone, where the light starts to fade.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The outer cutoff angle in degrees of the spotlight.</returns>
    /// <seealso>R3D_GetLightOuterCutOff</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightOuterCutOff")]
    public static partial float GetLightOuterCutOff(Light id);

    /// <summary>
    /// Sets the outer cutoff angle of a spotlight.
    /// <para>
    /// This function sets the outer cutoff angle of a spotlight. The outer cutoff defines the boundary of the light's cone where the light intensity starts to gradually decrease.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="degrees">The new outer cutoff angle in degrees.</param>
    /// <seealso>R3D_SetLightOuterCutOff</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetLightOuterCutOff")]
    public static partial void SetLightOuterCutOff(Light id, float degrees);

    /// <summary>
    /// Enables shadow rendering for a light.
    /// <para>
    /// Turns on shadow rendering for the light. The engine will allocate a shadow map if needed, or reuse one previously allocated for another light.
    /// </para>
    /// <para>
    /// Shadow map resolutions are fixed: 2048x2048 for spot and point lights, and 4096x4096 for directional lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <remarks>
    /// Creating too many shadow-casting lights can exhaust GPU memory and potentially crash the graphics driver. Disabling shadows on one light and enabling them on another is free, since existing shadow maps are reused.
    /// </remarks>
    /// <seealso>R3D_EnableShadow</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_EnableShadow")]
    public static partial void EnableShadow(Light id);

    /// <summary>
    /// Disables shadow rendering for a light.
    /// <para>
    /// Turns off shadow rendering for the light. The associated shadow map is kept in memory and may later be reused by another light.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <seealso>R3D_DisableShadow</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DisableShadow")]
    public static partial void DisableShadow(Light id);

    /// <summary>
    /// Checks if shadow casting is enabled for a light.
    /// <para>
    /// This function checks if shadow casting is currently enabled for the specified light.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>True if shadow casting is enabled, false otherwise.</returns>
    /// <seealso>R3D_IsShadowEnabled</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsShadowEnabled")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsShadowEnabled(Light id);

    /// <summary>
    /// Gets the shadow map update mode of a light.
    /// <para>
    /// This function retrieves the current mode for updating the shadow map of a light. The mode can be:
    /// <list type="bullet">
    /// <item><description>Interval: Updates the shadow map at a fixed interval.</description></item>
    /// <item><description>Continuous: Updates the shadow map continuously.</description></item>
    /// <item><description>Manual: Updates the shadow map manually (via explicit function calls).</description></item>
    /// </list>
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The shadow map update mode.</returns>
    /// <seealso>R3D_GetShadowUpdateMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetShadowUpdateMode")]
    public static partial ShadowUpdateMode GetShadowUpdateMode(Light id);

    /// <summary>
    /// Sets the shadow map update mode of a light.
    /// <para>
    /// This function sets the mode for updating the shadow map of the specified light. The update mode controls when and how often the shadow map is refreshed.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="mode">The update mode to set for the shadow map (Interval, Continuous, or Manual).</param>
    /// <seealso>R3D_SetShadowUpdateMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetShadowUpdateMode")]
    public static partial void SetShadowUpdateMode(Light id, ShadowUpdateMode mode);

    /// <summary>
    /// Gets the frequency of shadow map updates for the interval update mode.
    /// <para>
    /// This function retrieves the frequency (in milliseconds) at which the shadow map should be updated when the interval update mode is enabled. This function is only relevant if the shadow map update mode is set to &quot;Interval&quot;.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The frequency in milliseconds at which the shadow map is updated.</returns>
    /// <seealso>R3D_GetShadowUpdateFrequency</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetShadowUpdateFrequency")]
    public static partial int GetShadowUpdateFrequency(Light id);

    /// <summary>
    /// Sets the frequency of shadow map updates for the interval update mode.
    /// <para>
    /// This function sets the frequency (in milliseconds) at which the shadow map should be updated when the interval update mode is enabled. This function is only relevant if the shadow map update mode is set to &quot;Interval&quot;.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="msec">The frequency in milliseconds at which to update the shadow map.</param>
    /// <seealso>R3D_SetShadowUpdateFrequency</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetShadowUpdateFrequency")]
    public static partial void SetShadowUpdateFrequency(Light id, int msec);

    /// <summary>
    /// Forces an immediate update of the shadow map during the next rendering pass.
    /// <para>
    /// This function forces the shadow map of the specified light to be updated during the next call to `R3D_End`. This is primarily used for the manual update mode, but may also work for the interval mode.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <seealso>R3D_UpdateShadowMap</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_UpdateShadowMap")]
    public static partial void UpdateShadowMap(Light id);

    /// <summary>
    /// Retrieves the softness radius used to simulate penumbra in shadows.
    /// <para>
    /// The softness is expressed as a sampling radius in texels within the shadow map.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <returns>The softness radius in texels currently set for the shadow.</returns>
    /// <seealso>R3D_GetShadowSoftness</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetShadowSoftness")]
    public static partial float GetShadowSoftness(Light id);

    /// <summary>
    /// Sets the softness radius used to simulate penumbra in shadows.
    /// <para>
    /// This function adjusts the softness of the shadow edges for the specified light. The softness value corresponds to a number of texels in the shadow map, independent of its resolution. Larger values increase the blur radius, resulting in softer, more diffuse shadows, while smaller values yield sharper shadows.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <param name="softness">The softness radius in texels to apply (must be &gt;= 0).</param>
    /// <remarks>
    /// The softness must be set only after shadows have been enabled for the light, since the shadow map resolution must be known before the softness can be applied.
    /// </remarks>
    /// <seealso>R3D_SetShadowSoftness</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetShadowSoftness")]
    public static partial void SetShadowSoftness(Light id, float softness);

    /// <summary>
    /// Gets the shadow depth bias value.
    /// </summary>
    /// <seealso>R3D_GetShadowDepthBias</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetShadowDepthBias")]
    public static partial float GetShadowDepthBias(Light id);

    /// <summary>
    /// Sets the shadow depth bias value.
    /// <para>
    /// A higher bias helps reduce &quot;shadow acne&quot; artifacts (shadows flickering or appearing misaligned on surfaces). Be careful: too large values may cause shadows to look detached or floating away from objects.
    /// </para>
    /// </summary>
    /// <seealso>R3D_SetShadowDepthBias</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetShadowDepthBias")]
    public static partial void SetShadowDepthBias(Light id, float value);

    /// <summary>
    /// Gets the shadow slope bias value.
    /// </summary>
    /// <seealso>R3D_GetShadowSlopeBias</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetShadowSlopeBias")]
    public static partial float GetShadowSlopeBias(Light id);

    /// <summary>
    /// Sets the shadow slope bias value.
    /// <para>
    /// This bias mainly compensates artifacts on surfaces angled relative to the light. It helps prevent shadows from incorrectly appearing or disappearing along object edges.
    /// </para>
    /// </summary>
    /// <seealso>R3D_SetShadowSlopeBias</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetShadowSlopeBias")]
    public static partial void SetShadowSlopeBias(Light id, float value);

    /// <summary>
    /// Returns the bounding box encompassing the light's area of influence.
    /// <para>
    /// This function computes the axis-aligned bounding box (AABB) that encloses the volume affected by the specified light, based on its type:
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item><description>For spotlights, the bounding box encloses the light cone.</description></item>
    /// <item><description>For omni-directional lights, it encloses a sphere representing the light's range.</description></item>
    /// <item><description>For directional lights, it returns an infinite bounding box to represent global influence.</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// This bounding box is primarily useful for spatial partitioning, culling, or visual debugging.
    /// </para>
    /// </summary>
    /// <param name="light">The light for which to compute the bounding box.</param>
    /// <returns>A BoundingBox struct that encloses the light's influence volume.</returns>
    /// <seealso>R3D_GetLightBoundingBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetLightBoundingBox")]
    public static partial BoundingBox GetLightBoundingBox(Light light);

    /// <summary>
    /// Draws the area of influence of the light in 3D space.
    /// <para>
    /// This function visualizes the area affected by a light in 3D space. It draws the light's influence, such as the cone for spotlights or the volume for omni-lights. This function is only relevant for spotlights and omni-lights.
    /// </para>
    /// </summary>
    /// <param name="id">The ID of the light.</param>
    /// <remarks>
    /// This function should be called while using the default 3D rendering mode of raylib, not with R3D's rendering mode. It uses raylib's 3D drawing functions to render the light's shape.
    /// </remarks>
    /// <seealso>R3D_DrawLightShape</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DrawLightShape")]
    public static partial void DrawLightShape(Light id);

    /// <summary>
    /// Creates a new probe of the specified type.
    /// <para>
    /// The returned probe must be destroyed using ::R3D_DestroyProbe when it is no longer needed.
    /// </para>
    /// </summary>
    /// <param name="flags">IBL components that the probe must support.</param>
    /// <returns>A valid probe ID, or a negative value on failure.</returns>
    /// <seealso>R3D_CreateProbe</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CreateProbe")]
    public static partial Probe CreateProbe(ProbeFlags flags);

    /// <summary>
    /// Destroys a probe and frees its resources.
    /// </summary>
    /// <param name="id">Probe ID to destroy.</param>
    /// <seealso>R3D_DestroyProbe</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DestroyProbe")]
    public static partial void DestroyProbe(Probe id);

    /// <summary>
    /// Returns whether a probe exists.
    /// </summary>
    /// <param name="id">Probe ID.</param>
    /// <returns>true if the probe is valid and allocated, otherwise false.</returns>
    /// <seealso>R3D_IsProbeExist</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsProbeExist")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsProbeExist(Probe id);

    /// <summary>
    /// Returns the probe flags.
    /// </summary>
    /// <param name="id">Probe ID.</param>
    /// <returns>The flags assigned to the probe.</returns>
    /// <seealso>R3D_GetProbeFlags</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetProbeFlags")]
    public static partial ProbeFlags GetProbeFlags(Probe id);

    /// <summary>
    /// Returns whether a probe is currently active.
    /// <para>
    /// Inactive probes do not contribute to lighting.
    /// </para>
    /// </summary>
    /// <param name="id">Probe ID.</param>
    /// <returns>true if active, otherwise false.</returns>
    /// <seealso>R3D_IsProbeActive</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsProbeActive")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsProbeActive(Probe id);

    /// <summary>
    /// Enables or disables a probe.
    /// </summary>
    /// <param name="id">Probe ID.</param>
    /// <param name="active">Set to true to enable the probe.</param>
    /// <seealso>R3D_SetProbeActive</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetProbeActive")]
    public static partial void SetProbeActive(Probe id, [MarshalAs(UnmanagedType.I1)] bool active);

    /// <summary>
    /// Gets the probe update mode.
    /// <para>
    /// <list type="bullet">
    /// <item><description>R3D_PROBE_UPDATE_ONCE: Captured once, then reused unless its state changes.</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// <list type="bullet">
    /// <item><description>R3D_PROBE_UPDATE_ALWAYS: Recaptured every frame.</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// Use &quot;ONCE&quot; for static scenes, &quot;ALWAYS&quot; for highly dynamic scenes.
    /// </para>
    /// </summary>
    /// <seealso>R3D_GetProbeUpdateMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetProbeUpdateMode")]
    public static partial ProbeUpdateMode GetProbeUpdateMode(Probe id);

    /// <summary>
    /// Sets the probe update mode.
    /// <para>
    /// Controls when the probe capture is refreshed.
    /// </para>
    /// </summary>
    /// <param name="id">Probe ID.</param>
    /// <param name="mode">Update mode to apply.</param>
    /// <seealso>R3D_SetProbeUpdateMode</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetProbeUpdateMode")]
    public static partial void SetProbeUpdateMode(Probe id, ProbeUpdateMode mode);

    /// <summary>
    /// Returns whether the probe is considered indoors.
    /// <para>
    /// Indoor probes do not sample skybox or environment maps. Instead they rely only on ambient and background colors.
    /// </para>
    /// <para>
    /// Use this for rooms, caves, tunnels, etc... where outside lighting should not bleed inside.
    /// </para>
    /// </summary>
    /// <seealso>R3D_GetProbeInterior</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetProbeInterior")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool GetProbeInterior(Probe id);

    /// <summary>
    /// Enables or disables indoor mode for the probe.
    /// </summary>
    /// <seealso>R3D_SetProbeInterior</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetProbeInterior")]
    public static partial void SetProbeInterior(Probe id, [MarshalAs(UnmanagedType.I1)] bool active);

    /// <summary>
    /// Returns whether shadows are captured by this probe.
    /// <para>
    /// When enabled, shadowing is baked into the captured lighting. This improves realism, but increases capture cost.
    /// </para>
    /// </summary>
    /// <seealso>R3D_GetProbeShadows</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetProbeShadows")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool GetProbeShadows(Probe id);

    /// <summary>
    /// Enables or disables shadow rendering during probe capture.
    /// </summary>
    /// <seealso>R3D_SetProbeShadows</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetProbeShadows")]
    public static partial void SetProbeShadows(Probe id, [MarshalAs(UnmanagedType.I1)] bool active);

    /// <summary>
    /// Gets the world position of the probe.
    /// </summary>
    /// <seealso>R3D_GetProbePosition</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetProbePosition")]
    public static partial Vector3 GetProbePosition(Probe id);

    /// <summary>
    /// Sets the world position of the probe.
    /// </summary>
    /// <seealso>R3D_SetProbePosition</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetProbePosition")]
    public static partial void SetProbePosition(Probe id, Vector3 position);

    /// <summary>
    /// Gets the effective range of the probe.
    /// <para>
    /// The range defines the radius (in world units) within which this probe contributes to lighting. Objects outside this sphere receive no influence.
    /// </para>
    /// </summary>
    /// <seealso>R3D_GetProbeRange</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetProbeRange")]
    public static partial float GetProbeRange(Probe id);

    /// <summary>
    /// Sets the effective range of the probe.
    /// </summary>
    /// <param name="range">Radius in world units. Must be &gt; 0.</param>
    /// <seealso>R3D_SetProbeRange</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetProbeRange")]
    public static partial void SetProbeRange(Probe id, float range);

    /// <summary>
    /// Gets the falloff factor applied to probe contributions.
    /// <para>
    /// Falloff controls how lighting fades as distance increases.
    /// </para>
    /// <para>
    /// Internally this uses a power curve: attenuation = 1.0 - pow(dist / probe.range, probe.falloff)
    /// </para>
    /// <para>
    /// Effects:
    /// <list type="bullet">
    /// <item><description>falloff = 1 -&gt; linear fade</description></item>
    /// <item><description>falloff &gt; 1 -&gt; light stays strong near the probe, drops faster at the edge</description></item>
    /// <item><description>falloff &lt; 1 -&gt; softer fade across the whole range</description></item>
    /// </list>
    /// </para>
    /// </summary>
    /// <seealso>R3D_GetProbeFalloff</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetProbeFalloff")]
    public static partial float GetProbeFalloff(Probe id);

    /// <summary>
    /// Sets the falloff factor used for distance attenuation.
    /// <para>
    /// Larger values make the probe feel more localized.
    /// </para>
    /// </summary>
    /// <seealso>R3D_SetProbeFalloff</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SetProbeFalloff")]
    public static partial void SetProbeFalloff(Probe id, float falloff);

    /// <summary>
    /// Retrieves a default white texture.
    /// <para>
    /// This texture is fully white (1,1,1,1), useful for default material properties.
    /// </para>
    /// </summary>
    /// <returns>A white texture.</returns>
    /// <seealso>R3D_GetWhiteTexture</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetWhiteTexture")]
    public static partial Texture2D GetWhiteTexture();

    /// <summary>
    /// Retrieves a default black texture.
    /// <para>
    /// This texture is fully black (0,0,0,1), useful for masking or default values.
    /// </para>
    /// </summary>
    /// <returns>A black texture.</returns>
    /// <seealso>R3D_GetBlackTexture</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetBlackTexture")]
    public static partial Texture2D GetBlackTexture();

    /// <summary>
    /// Retrieves a default normal map texture.
    /// <para>
    /// This texture represents a neutral normal map (0.5, 0.5, 1.0), which applies no normal variation.
    /// </para>
    /// </summary>
    /// <returns>A neutral normal texture.</returns>
    /// <seealso>R3D_GetNormalTexture</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetNormalTexture")]
    public static partial Texture2D GetNormalTexture();

    /// <summary>
    /// Retrieves the buffer containing the scene's normal data.
    /// <para>
    /// This texture stores octahedral-compressed normals using two 16-bit per-channel RG components.
    /// </para>
    /// </summary>
    /// <returns>The normal buffer texture.</returns>
    /// <remarks>
    /// You can find the decoding functions in the embedded shaders, such as 'screen/lighting.fs.glsl'.
    /// </remarks>
    /// <seealso>R3D_GetBufferNormal</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetBufferNormal")]
    public static partial Texture2D GetBufferNormal();

    /// <summary>
    /// Retrieves the final depth buffer.
    /// <para>
    /// This texture contains the depth stored in 24 bits and a stencil buffer where each value is 0 or 1, indicating the presence of geometry. It is useful for post-processing effects outside of R3D.
    /// </para>
    /// </summary>
    /// <returns>The final depth buffer texture.</returns>
    /// <remarks>
    /// If you modify the texture parameters to sample the stencil instead of the depth, make sure to reset the parameters afterward.
    /// </remarks>
    /// <seealso>R3D_GetBufferDepth</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetBufferDepth")]
    public static partial Texture2D GetBufferDepth();

    /// <summary>
    /// Retrieves the view matrix.
    /// <para>
    /// This matrix represents the camera's transformation from world space to view space. It is updated at the last call to 'R3D_Begin'.
    /// </para>
    /// </summary>
    /// <returns>The current view matrix.</returns>
    /// <seealso>R3D_GetMatrixView</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetMatrixView")]
    public static partial Matrix4x4 GetMatrixView();

    /// <summary>
    /// Retrieves the inverse view matrix.
    /// <para>
    /// This matrix transforms coordinates from view space back to world space. It is updated at the last call to 'R3D_Begin'.
    /// </para>
    /// </summary>
    /// <returns>The current inverse view matrix.</returns>
    /// <seealso>R3D_GetMatrixInvView</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetMatrixInvView")]
    public static partial Matrix4x4 GetMatrixInvView();

    /// <summary>
    /// Retrieves the projection matrix.
    /// <para>
    /// This matrix defines the transformation from view space to clip space. It is updated at the last call to 'R3D_Begin'.
    /// </para>
    /// </summary>
    /// <returns>The current projection matrix.</returns>
    /// <seealso>R3D_GetMatrixProjection</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetMatrixProjection")]
    public static partial Matrix4x4 GetMatrixProjection();

    /// <summary>
    /// Retrieves the inverse projection matrix.
    /// <para>
    /// This matrix transforms coordinates from clip space back to view space. It is updated at the last call to 'R3D_Begin'.
    /// </para>
    /// </summary>
    /// <returns>The current inverse projection matrix.</returns>
    /// <seealso>R3D_GetMatrixInvProjection</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_GetMatrixInvProjection")]
    public static partial Matrix4x4 GetMatrixInvProjection();

}
