// Auto-generated by R3D-cs.GenerateBindings
// Do not edit manually

using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using Raylib_cs;
using static Raylib_cs.Raylib;

namespace R3D_cs;

// r3d_kinematics.h;

[SuppressUnmanagedCodeSecurity]
public static unsafe partial class R3D
{

    /// <summary>
    /// Check if capsule intersects with box
    /// </summary>
    /// <param name="capsule">Capsule shape</param>
    /// <param name="box">Bounding box</param>
    /// <returns>true if collision detected</returns>
    /// <seealso>R3D_CheckCollisionCapsuleBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CheckCollisionCapsuleBox")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool CheckCollisionCapsuleBox(Capsule capsule, BoundingBox box);

    /// <summary>
    /// Check if capsule intersects with sphere
    /// </summary>
    /// <param name="capsule">Capsule shape</param>
    /// <param name="center">Sphere center</param>
    /// <param name="radius">Sphere radius</param>
    /// <returns>true if collision detected</returns>
    /// <seealso>R3D_CheckCollisionCapsuleSphere</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CheckCollisionCapsuleSphere")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool CheckCollisionCapsuleSphere(Capsule capsule, Vector3 center, float radius);

    /// <summary>
    /// Check if two capsules intersect
    /// </summary>
    /// <param name="a">First capsule</param>
    /// <param name="b">Second capsule</param>
    /// <returns>true if collision detected</returns>
    /// <seealso>R3D_CheckCollisionCapsules</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CheckCollisionCapsules")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool CheckCollisionCapsules(Capsule a, Capsule b);

    /// <summary>
    /// Check if capsule intersects with mesh
    /// </summary>
    /// <param name="capsule">Capsule shape</param>
    /// <param name="mesh">Mesh data</param>
    /// <param name="transform">Mesh transform</param>
    /// <returns>true if collision detected</returns>
    /// <seealso>R3D_CheckCollisionCapsuleMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CheckCollisionCapsuleMesh")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool CheckCollisionCapsuleMesh(Capsule capsule, MeshData mesh, Matrix4x4 transform);

    /// <summary>
    /// Check penetration between capsule and box
    /// </summary>
    /// <param name="capsule">Capsule shape</param>
    /// <param name="box">Bounding box</param>
    /// <returns>Penetration information.</returns>
    /// <seealso>R3D_CheckPenetrationCapsuleBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CheckPenetrationCapsuleBox")]
    public static partial Penetration CheckPenetrationCapsuleBox(Capsule capsule, BoundingBox box);

    /// <summary>
    /// Check penetration between capsule and sphere
    /// </summary>
    /// <param name="capsule">Capsule shape</param>
    /// <param name="center">Sphere center</param>
    /// <param name="radius">Sphere radius</param>
    /// <returns>Penetration information.</returns>
    /// <seealso>R3D_CheckPenetrationCapsuleSphere</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CheckPenetrationCapsuleSphere")]
    public static partial Penetration CheckPenetrationCapsuleSphere(Capsule capsule, Vector3 center, float radius);

    /// <summary>
    /// Check penetration between two capsules
    /// </summary>
    /// <param name="a">First capsule</param>
    /// <param name="b">Second capsule</param>
    /// <returns>Penetration information.</returns>
    /// <seealso>R3D_CheckPenetrationCapsules</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_CheckPenetrationCapsules")]
    public static partial Penetration CheckPenetrationCapsules(Capsule a, Capsule b);

    /// <summary>
    /// Calculate slide velocity along surface
    /// </summary>
    /// <param name="velocity">Original velocity</param>
    /// <param name="normal">Surface normal (must be normalized)</param>
    /// <returns>Velocity sliding along surface (perpendicular component removed)</returns>
    /// <seealso>R3D_SlideVelocity</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SlideVelocity")]
    public static partial Vector3 SlideVelocity(Vector3 velocity, Vector3 normal);

    /// <summary>
    /// Calculate bounce velocity after collision
    /// </summary>
    /// <param name="velocity">Incoming velocity</param>
    /// <param name="normal">Surface normal (must be normalized)</param>
    /// <param name="bounciness">Coefficient of restitution (0=no bounce, 1=perfect bounce)</param>
    /// <returns>Reflected velocity</returns>
    /// <seealso>R3D_BounceVelocity</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_BounceVelocity")]
    public static partial Vector3 BounceVelocity(Vector3 velocity, Vector3 normal, float bounciness);

    /// <summary>
    /// Slide sphere along box surface, resolving collisions
    /// </summary>
    /// <param name="center">Sphere center position</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="velocity">Desired movement vector</param>
    /// <param name="box">Obstacle bounding box</param>
    /// <param name="outNormal">Optional: receives collision normal if collision occurred</param>
    /// <returns>Actual movement applied (may be reduced/redirected by collision)</returns>
    /// <seealso>R3D_SlideSphereBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SlideSphereBox")]
    public static partial Vector3 SlideSphereBox(Vector3 center, float radius, Vector3 velocity, BoundingBox box, ref Vector3 outNormal);

    /// <summary>
    /// Slide sphere along mesh surface, resolving collisions
    /// </summary>
    /// <param name="center">Sphere center position</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="velocity">Desired movement vector</param>
    /// <param name="mesh">Mesh data to collide against</param>
    /// <param name="transform">Mesh world transform</param>
    /// <param name="outNormal">Optional: receives collision normal if collision occurred</param>
    /// <returns>Actual movement applied (may be reduced/redirected by collision)</returns>
    /// <seealso>R3D_SlideSphereMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SlideSphereMesh")]
    public static partial Vector3 SlideSphereMesh(Vector3 center, float radius, Vector3 velocity, MeshData mesh, Matrix4x4 transform, ref Vector3 outNormal);

    /// <summary>
    /// Slide capsule along box surface, resolving collisions
    /// </summary>
    /// <param name="capsule">Capsule shape</param>
    /// <param name="velocity">Desired movement vector</param>
    /// <param name="box">Obstacle bounding box</param>
    /// <param name="outNormal">Optional: receives collision normal if collision occurred</param>
    /// <returns>Actual movement applied (may be reduced/redirected by collision)</returns>
    /// <seealso>R3D_SlideCapsuleBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SlideCapsuleBox")]
    public static partial Vector3 SlideCapsuleBox(Capsule capsule, Vector3 velocity, BoundingBox box, ref Vector3 outNormal);

    /// <summary>
    /// Slide capsule along mesh surface, resolving collisions
    /// </summary>
    /// <param name="capsule">Capsule shape</param>
    /// <param name="velocity">Desired movement vector</param>
    /// <param name="mesh">Mesh data to collide against</param>
    /// <param name="transform">Mesh world transform</param>
    /// <param name="outNormal">Optional: receives collision normal if collision occurred</param>
    /// <returns>Actual movement applied (may be reduced/redirected by collision)</returns>
    /// <seealso>R3D_SlideCapsuleMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SlideCapsuleMesh")]
    public static partial Vector3 SlideCapsuleMesh(Capsule capsule, Vector3 velocity, MeshData mesh, Matrix4x4 transform, ref Vector3 outNormal);

    /// <summary>
    /// Push sphere out of box if penetrating
    /// </summary>
    /// <param name="center">Sphere center (modified in place if penetrating)</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="box">Obstacle box</param>
    /// <param name="outPenetration">Optional: receives penetration depth</param>
    /// <returns>true if depenetration occurred</returns>
    /// <seealso>R3D_DepenetrateSphereBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DepenetrateSphereBox")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool DepenetrateSphereBox(ref Vector3 center, float radius, BoundingBox box, ref float outPenetration);

    /// <summary>
    /// Push capsule out of box if penetrating
    /// </summary>
    /// <param name="capsule">Capsule shape (modified in place if penetrating)</param>
    /// <param name="box">Obstacle box</param>
    /// <param name="outPenetration">Optional: receives penetration depth</param>
    /// <returns>true if depenetration occurred</returns>
    /// <seealso>R3D_DepenetrateCapsuleBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_DepenetrateCapsuleBox")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool DepenetrateCapsuleBox(ref Capsule capsule, BoundingBox box, ref float outPenetration);

    /// <summary>
    /// Cast a ray against mesh geometry
    /// </summary>
    /// <param name="ray">Ray to cast</param>
    /// <param name="mesh">Mesh data to test against</param>
    /// <param name="transform">Mesh world transform</param>
    /// <returns>Ray collision info (hit, distance, point, normal)</returns>
    /// <seealso>R3D_RaycastMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_RaycastMesh")]
    public static partial RayCollision RaycastMesh(Ray ray, MeshData mesh, Matrix4x4 transform);

    /// <summary>
    /// Cast a ray against a model (tests all meshes)
    /// </summary>
    /// <param name="ray">Ray to cast</param>
    /// <param name="model">Model to test against (must have valid meshData)</param>
    /// <param name="transform">Model world transform</param>
    /// <returns>Ray collision info for closest hit (hit=false if no meshData)</returns>
    /// <seealso>R3D_RaycastModel</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_RaycastModel")]
    public static partial RayCollision RaycastModel(Ray ray, Model model, Matrix4x4 transform);

    /// <summary>
    /// Sweep sphere against single point
    /// </summary>
    /// <param name="center">Sphere center position</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="velocity">Movement vector (direction and magnitude)</param>
    /// <param name="point">Point to test against</param>
    /// <returns>Sweep collision info (hit, time, point, normal)</returns>
    /// <seealso>R3D_SweepSpherePoint</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SweepSpherePoint")]
    public static partial SweepCollision SweepSpherePoint(Vector3 center, float radius, Vector3 velocity, Vector3 point);

    /// <summary>
    /// Sweep sphere against line segment
    /// </summary>
    /// <param name="center">Sphere center position</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="velocity">Movement vector (direction and magnitude)</param>
    /// <param name="a">Segment start point</param>
    /// <param name="b">Segment end point</param>
    /// <returns>Sweep collision info (hit, time, point, normal)</returns>
    /// <seealso>R3D_SweepSphereSegment</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SweepSphereSegment")]
    public static partial SweepCollision SweepSphereSegment(Vector3 center, float radius, Vector3 velocity, Vector3 a, Vector3 b);

    /// <summary>
    /// Sweep sphere against triangle plane (no edge/vertex clipping)
    /// </summary>
    /// <param name="center">Sphere center position</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="velocity">Movement vector (direction and magnitude)</param>
    /// <param name="a">Triangle vertex A</param>
    /// <param name="b">Triangle vertex B</param>
    /// <param name="c">Triangle vertex C</param>
    /// <returns>Sweep collision info (hit, time, point, normal)</returns>
    /// <seealso>R3D_SweepSphereTrianglePlane</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SweepSphereTrianglePlane")]
    public static partial SweepCollision SweepSphereTrianglePlane(Vector3 center, float radius, Vector3 velocity, Vector3 a, Vector3 b, Vector3 c);

    /// <summary>
    /// Sweep sphere against triangle with edge/vertex handling
    /// </summary>
    /// <param name="center">Sphere center position</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="velocity">Movement vector (direction and magnitude)</param>
    /// <param name="a">Triangle vertex A</param>
    /// <param name="b">Triangle vertex B</param>
    /// <param name="c">Triangle vertex C</param>
    /// <returns>Sweep collision info (hit, time, point, normal)</returns>
    /// <seealso>R3D_SweepSphereTriangle</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SweepSphereTriangle")]
    public static partial SweepCollision SweepSphereTriangle(Vector3 center, float radius, Vector3 velocity, Vector3 a, Vector3 b, Vector3 c);

    /// <summary>
    /// Sweep sphere along velocity vector
    /// </summary>
    /// <param name="center">Sphere center position</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="velocity">Movement vector (direction and magnitude)</param>
    /// <param name="box">Obstacle bounding box</param>
    /// <returns>Sweep collision info (hit, distance, point, normal)</returns>
    /// <seealso>R3D_SweepSphereBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SweepSphereBox")]
    public static partial SweepCollision SweepSphereBox(Vector3 center, float radius, Vector3 velocity, BoundingBox box);

    /// <summary>
    /// Sweep sphere along velocity vector against mesh geometry
    /// </summary>
    /// <param name="center">Sphere center position</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="velocity">Movement vector (direction and magnitude)</param>
    /// <param name="mesh">Mesh data to test against</param>
    /// <param name="transform">Mesh world transform</param>
    /// <returns>Sweep collision info (hit, time, point, normal)</returns>
    /// <seealso>R3D_SweepSphereMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SweepSphereMesh")]
    public static partial SweepCollision SweepSphereMesh(Vector3 center, float radius, Vector3 velocity, MeshData mesh, Matrix4x4 transform);

    /// <summary>
    /// Sweep capsule along velocity vector
    /// </summary>
    /// <param name="capsule">Capsule shape to sweep</param>
    /// <param name="velocity">Movement vector (direction and magnitude)</param>
    /// <param name="box">Obstacle bounding box</param>
    /// <returns>Sweep collision info (hit, distance, point, normal)</returns>
    /// <seealso>R3D_SweepCapsuleBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SweepCapsuleBox")]
    public static partial SweepCollision SweepCapsuleBox(Capsule capsule, Vector3 velocity, BoundingBox box);

    /// <summary>
    /// Sweep capsule along velocity vector against mesh geometry
    /// </summary>
    /// <param name="capsule">Capsule shape to sweep</param>
    /// <param name="velocity">Movement vector (direction and magnitude)</param>
    /// <param name="mesh">Mesh data to test against</param>
    /// <param name="transform">Mesh world transform</param>
    /// <returns>Sweep collision info (hit, time, point, normal)</returns>
    /// <seealso>R3D_SweepCapsuleMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_SweepCapsuleMesh")]
    public static partial SweepCollision SweepCapsuleMesh(Capsule capsule, Vector3 velocity, MeshData mesh, Matrix4x4 transform);

    /// <summary>
    /// Check if sphere is grounded against a box
    /// </summary>
    /// <param name="center">Sphere center</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="checkDistance">How far below to check</param>
    /// <param name="ground">Ground box to test against</param>
    /// <param name="outGround">Optional: receives raycast hit info</param>
    /// <returns>true if grounded within checkDistance</returns>
    /// <seealso>R3D_IsSphereGroundedBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsSphereGroundedBox")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsSphereGroundedBox(Vector3 center, float radius, float checkDistance, BoundingBox ground, ref RayCollision outGround);

    /// <summary>
    /// Check if sphere is grounded against mesh geometry
    /// </summary>
    /// <param name="center">Sphere center</param>
    /// <param name="radius">Sphere radius</param>
    /// <param name="checkDistance">How far below to check</param>
    /// <param name="mesh">Mesh data to test against</param>
    /// <param name="transform">Mesh world transform</param>
    /// <param name="outGround">Optional: receives raycast hit info</param>
    /// <returns>true if grounded within checkDistance</returns>
    /// <seealso>R3D_IsSphereGroundedMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsSphereGroundedMesh")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsSphereGroundedMesh(Vector3 center, float radius, float checkDistance, MeshData mesh, Matrix4x4 transform, ref RayCollision outGround);

    /// <summary>
    /// Check if capsule is grounded against a box
    /// </summary>
    /// <param name="capsule">Character capsule</param>
    /// <param name="checkDistance">How far below to check (e.g., 0.1)</param>
    /// <param name="ground">Ground box to test against</param>
    /// <param name="outGround">Optional: receives raycast hit info</param>
    /// <returns>true if grounded within checkDistance</returns>
    /// <seealso>R3D_IsCapsuleGroundedBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsCapsuleGroundedBox")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsCapsuleGroundedBox(Capsule capsule, float checkDistance, BoundingBox ground, ref RayCollision outGround);

    /// <summary>
    /// Check if capsule is grounded against mesh geometry
    /// </summary>
    /// <param name="capsule">Character capsule</param>
    /// <param name="checkDistance">How far below to check</param>
    /// <param name="mesh">Mesh data to test against</param>
    /// <param name="transform">Mesh world transform</param>
    /// <param name="outGround">Optional: receives raycast hit info</param>
    /// <returns>true if grounded within checkDistance</returns>
    /// <seealso>R3D_IsCapsuleGroundedMesh</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_IsCapsuleGroundedMesh")]
    [return: MarshalAs(UnmanagedType.I1)]
    public static partial bool IsCapsuleGroundedMesh(Capsule capsule, float checkDistance, MeshData mesh, Matrix4x4 transform, ref RayCollision outGround);

    /// <summary>
    /// Find closest point on line segment to given point
    /// </summary>
    /// <param name="point">Query point</param>
    /// <param name="start">Segment start</param>
    /// <param name="end">Segment end</param>
    /// <returns>Closest point on segment [start, end]</returns>
    /// <seealso>R3D_ClosestPointOnSegment</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_ClosestPointOnSegment")]
    public static partial Vector3 ClosestPointOnSegment(Vector3 point, Vector3 start, Vector3 end);

    /// <summary>
    /// Find closest point on triangle to given point
    /// </summary>
    /// <param name="p">Query point</param>
    /// <param name="a">Triangle vertex A</param>
    /// <param name="b">Triangle vertex B</param>
    /// <param name="c">Triangle vertex C</param>
    /// <returns>Closest point on triangle surface</returns>
    /// <seealso>R3D_ClosestPointOnTriangle</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_ClosestPointOnTriangle")]
    public static partial Vector3 ClosestPointOnTriangle(Vector3 p, Vector3 a, Vector3 b, Vector3 c);

    /// <summary>
    /// Find closest point on box surface to given point
    /// </summary>
    /// <param name="point">Query point</param>
    /// <param name="box">Bounding box</param>
    /// <returns>Closest point on/in box (clamped to box bounds)</returns>
    /// <seealso>R3D_ClosestPointOnBox</seealso>
    [LibraryImport(NativeLibName, EntryPoint = "R3D_ClosestPointOnBox")]
    public static partial Vector3 ClosestPointOnBox(Vector3 point, BoundingBox box);

}
