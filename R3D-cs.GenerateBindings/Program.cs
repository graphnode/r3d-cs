using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using CppAst;
using LibGit2Sharp;

namespace R3D_cs.GenerateBindings;

internal static class Program
{
    private const string Namespace = "R3D_cs";
    private const string NativeLibName = "r3d";
    
    private static readonly string TargetProjectDir = Path.GetFullPath("../R3D-cs", GetProjectDirectory());

    private static void GenerateEnumsFiles(CppCompilation compilation)
    {
        foreach (var @enum in compilation.Enums)
        {
            if (!IsR3DSource(@enum.SourceFile))
                continue;
            
            string name = StripR3DPrefix(@enum.Name);
            bool isBitflag = name.EndsWith("Flags");
            string enumName = isBitflag ? name[..^5] : name;

            var sb = new StringBuilder();
            sb.AppendLine("// Auto-generated by R3D-cs.GenerateBindings");
            sb.AppendLine("// Do not edit manually");
            sb.AppendLine();
            sb.AppendLine($"namespace {Namespace};");
            sb.AppendLine();
            
            CommentGenerator.Generate(sb, @enum.Comment, @enum.Name);
            
            if (isBitflag)
                sb.AppendLine("[Flags]");
            
            sb.Append($"public enum {name}");
            (string type, _, _, _) = MapType(@enum.IntegerType);
            if (type != "int")
                sb.Append($" : {type}");
            sb.AppendLine();
            sb.AppendLine("{");

            string prefix = name;
            if (name.EndsWith("Mode", StringComparison.OrdinalIgnoreCase)) prefix = name[..^4];
            if (name.EndsWith("Type", StringComparison.OrdinalIgnoreCase)) prefix = name[..^4];

            for (var i = 0; i < @enum.Items.Count; i++)
            {
                var item = @enum.Items[i];
                string itemName = ToPascalCase(StripR3DPrefix(item.Name));

                if (itemName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                    itemName = itemName[prefix.Length..];

                bool hasComment = CommentGenerator.Generate(sb, item.Comment, $"{@enum.Name}.{item.Name}", prefix: "    ");

                if (isBitflag)
                    sb.AppendLine($"    {itemName} = {item.Value},");
                else
                    sb.AppendLine($"    {itemName},");

                if (i < @enum.Items.Count - 1 && hasComment)
                    sb.AppendLine();
            }

            sb.AppendLine("}");
            
            File.WriteAllText(Path.Combine(TargetProjectDir, "enums", $"{enumName}.g.cs"), sb.ToString());
        }
    }

    private static void GenerateStructsFiles(CppCompilation compilation)
    {
        foreach (var @class in compilation.Classes)
        {
            if (!IsR3DSource(@class.SourceFile))
                continue;

            if (@class.ClassKind != CppClassKind.Struct)
                throw new Exception($"Unexpected class kind: {@class.ClassKind}");

            var sb = new StringBuilder();
            GenerateHeader(sb, ["System", "System.Numerics", "System.Runtime.InteropServices", "Raylib_cs"]);
            
            string className = StripR3DPrefix(@class.Name);
            bool needsUnsafe = @class.Fields.Select((f) => MapType(f.Type)).Any(r => r.isUnsafe);
            
            CommentGenerator.Generate(sb, @class.Comment, @class.Name);
            
            sb.AppendLine("[StructLayout(LayoutKind.Sequential)]");
            sb.Append($"public {(needsUnsafe ? "unsafe " : "")}struct {className}");
            sb.AppendLine();
            sb.AppendLine("{");
            
            foreach (var field in @class.Fields)
            {
                (string csType, _, bool isFixedBuffer, int fixedSize) = MapType(field.Type);
                
                string fieldType = StripR3DPrefix(csType);
                string fieldName = EscapeIdentifier(ToPascalCase(field.Name));

                // Override for callbacks.
                if (fieldName.EndsWith("Callback", StringComparison.OrdinalIgnoreCase))
                    fieldType = "IntPtr";
                
                CommentGenerator.Generate(sb, field.Comment, field.Name, prefix: "    ");
                
                if (isFixedBuffer)
                    sb.AppendLine($"    public fixed {fieldType} {fieldName}[{fixedSize}];");
                else
                    sb.AppendLine($"    public {fieldType} {fieldName};");

                sb.AppendLine();
            }
            
            sb.AppendLine("}");
            
            File.WriteAllText(Path.Combine(TargetProjectDir, "types", $"{className}.g.cs"), sb.ToString());
        }
    }

    private static void GenerateMiscFiles(CppCompilation compilation)
    {
        foreach (var typedef in compilation.Typedefs)
        {
            if (!IsR3DSource(typedef.SourceFile))
                continue;

            string name = StripR3DPrefix(typedef.Name);

            // Callbacks (function pointers)
            if (typedef.Name.EndsWith("Callback"))
            {
                if (typedef.ElementType is CppPointerType { ElementType: CppFunctionType funcType })
                {
                    (string returnType, _, _, _) = MapType(funcType.ReturnType);

                    var sb = new StringBuilder();
                    GenerateHeader(sb, ["System", "System.Numerics", "System.Runtime.InteropServices", "Raylib_cs"]);
                    
                    CommentGenerator.Generate(sb, typedef.Comment, typedef.Name);
                    
                    sb.AppendLine("[UnmanagedFunctionPointer(CallingConvention.Cdecl)]");
                    sb.Append($"public unsafe delegate {returnType} {name}(");

                    for (var i = 0; i < funcType.Parameters.Count; i++)
                    {
                        var param = funcType.Parameters[i];
                        
                        (string paramType, _, _, _) = MapType(param.Type);
                        sb.Append($"{StripR3DPrefix(paramType)} {param.Name}");

                        if (i < funcType.Parameters.Count - 1)
                            sb.Append(", ");
                    }
                    
                    sb.AppendLine(");");
                    sb.AppendLine();
                    
                    File.WriteAllText(Path.Combine(TargetProjectDir, "types", $"{name}.g.cs"), sb.ToString());
                }
                continue;
            }

            // Check for macro-based enums
            bool isBitflag = name.EndsWith("Flags");
            string enumName = isBitflag ? name[..^5] : name;
            string prefix = "R3D_" + enumName.ToUpperInvariant() + "_";

            var options = new List<CppMacro>();
            foreach (var macro in compilation.Macros)
            {
                if (macro.SourceFile != typedef.SourceFile || macro.Span.Start.Line < typedef.Span.End.Line)
                    continue;

                if (!macro.Name.StartsWith(prefix))
                    continue;
                
                options.Add(macro);
            }

            if (options.Count > 0)
            {
                var sb = new StringBuilder();
                GenerateHeader(sb, ["System", "System.Numerics", "System.Runtime.InteropServices", "Raylib_cs"]);
                    
                CommentGenerator.Generate(sb, typedef.Comment, typedef.Name);
                
                sb.AppendLine("[Flags]");
                sb.Append($"public enum {name}");
                (string type, _, _, _) = MapType(typedef.ElementType);
                if (type != "int")
                    sb.Append($" : {type}");
                sb.AppendLine();                
                sb.AppendLine("{");
                
                for (var i = 0; i < options.Count; i++)
                {
                    var macro = options[i];
                    
                    string optionName = ToPascalCase(macro.Name[prefix.Length..]);

                    if (optionName.All(char.IsDigit))
                        optionName = ToPascalCase(StripR3DPrefix(macro.Name));
                    
                    if (optionName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                        optionName = optionName[prefix.Length..];
                    
                    bool hasComment = CommentGenerator.GenerateForMacro(sb, macro, macro.Name, prefix: "    ");

                    sb.AppendLine($"    {optionName} = {macro.Value},");
                    
                    if (i < options.Count - 1 && hasComment)
                        sb.AppendLine();
                }

                sb.AppendLine("}");
                    
                File.WriteAllText(Path.Combine(TargetProjectDir, "enums", $"{name}.g.cs"), sb.ToString());
                continue;
            }

            // Opaque handle types (typedef int32_t R3D_Something)
            if (typedef.ElementType is CppPrimitiveType { Kind: CppPrimitiveKind.Int })
            {
                var sb = new StringBuilder();
                GenerateHeader(sb);
                
                CommentGenerator.Generate(sb, typedef.Comment, typedef.Name);
                
                sb.AppendLine($"public struct {name}");
                sb.AppendLine("{");
                sb.AppendLine("    internal int id;");
                sb.AppendLine();
                sb.AppendLine($"    public static explicit operator int({name} handle) => handle.id;");
                sb.AppendLine($"    public static explicit operator {name}(int id) => new() {{ id = id }};");
                sb.AppendLine("}");
                
                File.WriteAllText(Path.Combine(TargetProjectDir, "types", $"{name}.g.cs"), sb.ToString());
            }
        }
    }
    
    private static void GenerateInteropFile(CppCompilation compilation)
    {
        var sb = new StringBuilder();
        GenerateHeader(sb, 
            ["System", "System.Numerics", "System.Runtime.CompilerServices", "System.Runtime.InteropServices", "System.Security", "Raylib_cs", "static Raylib_cs.Raylib"], 
            ["[assembly: DisableRuntimeMarshalling]"]);
        sb.AppendLine("[SuppressUnmanagedCodeSecurity]");
        sb.AppendLine("public static unsafe partial class R3D");
        sb.AppendLine("{");
        sb.AppendLine($"    public const string NativeLibName = \"{NativeLibName}\";");
        sb.AppendLine();

        // Process functions
        foreach (var function in compilation.Functions)
        {
            if (!IsR3DSource(function.SourceFile))
                continue;

            string? name = function.Name;
            (string returnType, _, _, _) = MapType(function.ReturnType);
            var hasStringParam = function.Parameters.Any(p => p.Type is CppPointerType { ElementType: CppQualifiedType { ElementType: CppPrimitiveType { Kind: CppPrimitiveKind.Char } } });

            CommentGenerator.Generate(sb, function.Comment, name, prefix: "    ");

            sb.Append("    [LibraryImport(NativeLibName");
            sb.Append($", EntryPoint = \"{name}\"");
            if (hasStringParam)
                sb.Append(", StringMarshalling = StringMarshalling.Utf8");
            sb.AppendLine(")]");

            if (returnType == "bool")
                sb.AppendLine("    [return: MarshalAs(UnmanagedType.I1)]");

            sb.Append($"    public static partial {StripR3DPrefix(returnType)} {StripR3DPrefix(name)}(");
            for (var i = 0; i < function.Parameters.Count; i++)
            {
                if (i > 0)
                    sb.Append(", ");

                var param = function.Parameters[i];
                (string paramType, _, _, _) = MapType(param.Type);

                if (paramType == "bool")
                    sb.Append("[MarshalAs(UnmanagedType.I1)] ");

                // Convert pointer parameters to ref/out where appropriate
                var (modifier, finalType) = GetParameterModifier(param.Type, paramType, name);
                if (modifier != null)
                    sb.Append($"{modifier} ");

                sb.Append($"{StripR3DPrefix(finalType)} {EscapeIdentifier(StripR3DPrefix(param.Name))}");
            }

            sb.AppendLine(");");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        File.WriteAllText(Path.Combine(TargetProjectDir, "interop", "R3D.g.cs"), sb.ToString());
    }
    
    private static void Main()
    {
        // Clone repository if needed
        if (!Directory.Exists("r3d-upstream"))
        {
            Repository.Clone(
                "https://github.com/Bigfoot71/r3d/",
                "r3d-upstream",
                new CloneOptions
                {
                    RecurseSubmodules = true,
                    Checkout = true,
                    FetchOptions = { Depth = 1 },
                    OnCheckoutProgress = (path, steps, totalSteps) => Console.WriteLine($"Cloning {path} ({steps}/{totalSteps})")
                });
        }

        // Parse C header
        var compilation = CppParser.ParseFile(@"r3d-upstream\include\r3d\r3d.h", new CppParserOptions
        {
            IncludeFolders = { @"r3d-upstream\external\raylib\src" },
            ParseMacros = false,
            ParserKind = CppParserKind.C,
            ParseCommentAttribute = true,
            ParseComments = true,
        });

        if (compilation.HasErrors)
        {
            foreach (var message in compilation.Diagnostics.Messages)
                Console.WriteLine(message.Text);
            return;
        }
        
        // Clear output directories
        ClearDirectory(Path.Combine(TargetProjectDir, "enums"));
        ClearDirectory(Path.Combine(TargetProjectDir, "types"));
        ClearDirectory(Path.Combine(TargetProjectDir, "interop"));
        
        GenerateEnumsFiles(compilation);
        GenerateStructsFiles(compilation);
        GenerateMiscFiles(compilation);
        GenerateInteropFile(compilation);
    }
    
    private static string GetProjectDirectory([CallerFilePath] string? path = null) => Path.GetDirectoryName(path)!;

    private static void ClearDirectory(string directory)
    {
        if (Directory.Exists(directory))
        {
            // Only delete generated files (*.g.cs), preserve hand-written files
            foreach (var file in Directory.GetFiles(directory, "*.g.cs"))
                File.Delete(file);
        }
        else
        {
            Directory.CreateDirectory(directory);
        }
    }

    private static void GenerateHeader(StringBuilder sb, List<string>? includes = null, List<string>? other = null)
    {
        sb.AppendLine("// Auto-generated by R3D-cs.GenerateBindings");
        sb.AppendLine("// Do not edit manually");
        sb.AppendLine();
        if (includes != null)
        {
            foreach (string include in includes)
                sb.AppendLine($"using {include};");
            sb.AppendLine();
        }
        if (other != null)
        {
            foreach (string line in other)
                sb.AppendLine(line);
            sb.AppendLine();
        }
        sb.AppendLine($"namespace {Namespace};");
        sb.AppendLine();
    }
    
    private static bool IsR3DSource(string? sourceFile) => sourceFile != null && sourceFile.Contains("r3d-upstream\\include\\");

    private static string StripR3DPrefix(string name) => name.StartsWith("R3D_") ? name[4..] : name;
    
    private static string ToPascalCase(string input)
    {
        string[] parts = input.Split('_');
        for (var i = 0; i < parts.Length; i++)
        {
            if (parts[i].Length == 0) continue;
            if (parts[i].All(char.IsUpper))
                parts[i] = char.ToUpper(parts[i][0]) + parts[i][1..].ToLower();
            else
                parts[i] = char.ToUpper(parts[i][0]) + parts[i][1..];
        }
        return string.Join("", parts);
    }

    /// <summary>
    /// Determines if a pointer parameter should use ref/out modifiers instead of raw pointers.
    /// </summary>
    private static (string? modifier, string finalType) GetParameterModifier(CppType type, string mappedType, string? functionName)
    {
        // Only process pointer types
        if (type is not CppPointerType ptrType)
            return (null, mappedType);

        // Get the unqualified element type
        var elementType = ptrType.ElementType;
        if (elementType is CppQualifiedType t)
            elementType = t.ElementType;

        // Keep void* / const void* as IntPtr (raw memory buffers)
        if (elementType is CppPrimitiveType { Kind: CppPrimitiveKind.Void })
            return (null, mappedType);

        // Keep const char* as string (already handled)
        if (elementType is CppPrimitiveType { Kind: CppPrimitiveKind.Char })
            return (null, mappedType);

        // Get the underlying type name
        string elementTypeName = ptrType.ElementType switch
        {
            CppTypedef td => td.Name,
            CppClass cls => cls.Name,
            CppQualifiedType qt => qt.ElementType switch
            {
                CppTypedef td => td.Name,
                CppClass cls => cls.Name,
                _ => ""
            },
            CppPrimitiveType pt => pt.Kind.ToString().ToLower(),
            _ => ""
        };

        // Types that should stay as pointers (opaque handles, optional parameters)
        HashSet<string> keepAsPointer = ["R3D_Importer", "R3D_Environment", "R3D_BoundingBox", "BoundingBox"];
        if (keepAsPointer.Contains(elementTypeName))
            return (null, mappedType);

        // Primitive pointers in Get* functions become out parameters
        if (functionName?.StartsWith("R3D_Get") == true && ptrType.ElementType is CppPrimitiveType)
        {
            string baseType = mappedType.TrimEnd('*');
            return ("out", baseType);
        }

        // Other struct/type pointers become ref parameters
        if (mappedType.EndsWith("*"))
        {
            string baseType = mappedType.TrimEnd('*');
            return ("ref", baseType);
        }

        return (null, mappedType);
    }

    private static (string csType, bool isUnsafe, bool isFixedBuffer, int fixedSize) MapType(CppType type)
    {
        // Exceptions for Raylib
        switch (type.FullName)
        {
            case "RenderTexture": return ("RenderTexture2D", false, false, 0);
            case "Texture": return ("Texture2D", false, false, 0);
        }
        
        return type switch
        {
            CppPrimitiveType pt => pt.Kind switch
            {
                CppPrimitiveKind.Void => ("void", false, false, 0),
                CppPrimitiveKind.Bool => ("bool", false, false, 0),
                CppPrimitiveKind.Char => ("byte", false, false, 0),
                CppPrimitiveKind.Short => ("short", false, false, 0),
                CppPrimitiveKind.Int => ("int", false, false, 0),
                CppPrimitiveKind.LongLong => ("long", false, false, 0),
                CppPrimitiveKind.UnsignedChar => ("byte", false, false, 0),
                CppPrimitiveKind.UnsignedShort => ("ushort", false, false, 0),
                CppPrimitiveKind.UnsignedInt => ("uint", false, false, 0),
                CppPrimitiveKind.UnsignedLongLong => ("ulong", false, false, 0),
                CppPrimitiveKind.Float => ("float", false, false, 0),
                CppPrimitiveKind.Double => ("double", false, false, 0),
                _ => ("IntPtr", false, false, 0)
            },

            CppPointerType ptr => ptr.ElementType switch
            {
                CppPrimitiveType { Kind: CppPrimitiveKind.Void } => ("IntPtr", false, false, 0),
                CppQualifiedType { ElementType: CppPrimitiveType { Kind: CppPrimitiveKind.Char } } => ("string", false, false, 0), // const char*
                _ => (MapType(ptr.ElementType).csType + "*", true, false, 0)
            },

            CppArrayType arr => (MapType(arr.ElementType).csType, true, true, arr.Size),

            CppQualifiedType qt => MapType(qt.ElementType),

            CppTypedef td => MapTypedefType(td.Name),

            CppClass cls => MapStructType(cls.Name),

            CppEnum en => ("R3D_" + StripR3DPrefix(en.Name), false, false, 0),

            _ => ("IntPtr", false, false, 0)
        };
    }

    private static (string, bool, bool, int) MapTypedefType(string name)
    {
        // Keep R3D_ prefix for our types
        if (name.StartsWith("R3D_"))
            return ("R3D_" + StripR3DPrefix(name), false, false, 0);

        // External types
        return (name, false, false, 0);
    }

    private static (string, bool, bool, int) MapStructType(string name)
    {
        if (name.StartsWith("R3D_"))
            return ("R3D_" + StripR3DPrefix(name), false, false, 0);

        if (name == "Matrix")
            return ("Matrix4x4", false, false, 0);

        return (name, false, false, 0);
    }

    private static string EscapeIdentifier(string name)
    {
        HashSet<string> keywords =
        [
            "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char",
            "checked", "class", "const", "continue", "decimal", "default", "delegate",
            "do", "double", "else", "enum", "event", "explicit", "extern", "false",
            "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit",
            "in", "int", "interface", "internal", "is", "lock", "long", "namespace",
            "new", "null", "object", "operator", "out", "override", "params", "private",
            "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
            "short", "sizeof", "stackalloc", "static", "string", "struct", "switch",
            "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked",
            "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"
        ];

        return keywords.Contains(name) ? "@" + name : name;
    }
}
