using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using CppAst;
using static R3D_cs.GenerateBindings.StringHelpers;
using static R3D_cs.GenerateBindings.TypeMapper;

namespace R3D_cs.GenerateBindings;

/// <summary>
///     Generates C# binding code from parsed C++ headers.
/// </summary>
public class CodeGenerator(string outputDir)
{
    private const string Namespace = "R3D_cs";
    private const string NativeLibName = "r3d";

    /// <summary>
    ///     Generates all binding files from the parsed compilation.
    /// </summary>
    public void Generate(CppCompilation compilation, string version)
    {
        // Identify opaque types (structs with no fields) before generating
        TypeMapper.OpaqueTypes.Clear();
        foreach (var @class in compilation.Classes)
        {
            if (!IsR3DSource(@class.SourceFile))
                continue;
            if (@class.ClassKind == CppClassKind.Struct && @class.Fields.Count == 0)
                TypeMapper.OpaqueTypes.Add(@class.Name);
        }

        if (TypeMapper.OpaqueTypes.Count > 0)
            Console.WriteLine($"Detected opaque types: {string.Join(", ", TypeMapper.OpaqueTypes)}");

        // Clear output directories
        Console.WriteLine("Preparing output directories...");
        ClearDirectory(Path.Combine(outputDir, "enums"));
        ClearDirectory(Path.Combine(outputDir, "types"));
        ClearDirectory(Path.Combine(outputDir, "interop"));

        // Generate files
        Console.WriteLine("Generating enum bindings...");
        int enumCount = GenerateEnumsFiles(compilation);
        Console.WriteLine($"  Generated {enumCount} enum files");

        Console.WriteLine("Generating struct bindings...");
        int structCount = GenerateStructsFiles(compilation);
        Console.WriteLine($"  Generated {structCount} struct files");

        Console.WriteLine("Generating misc bindings (typedefs, handles, callbacks)...");
        int miscCount = GenerateMiscFiles(compilation);
        Console.WriteLine($"  Generated {miscCount} misc files");

        Console.WriteLine("Generating interop file...");
        int funcCount = GenerateInteropFiles(compilation, version);
        Console.WriteLine($"  Generated interop file with {funcCount} functions");
    }

    private int GenerateEnumsFiles(CppCompilation compilation)
    {
        var count = 0;

        foreach (var @enum in compilation.Enums)
        {
            if (!IsR3DSource(@enum.SourceFile))
                continue;

            string name = StripR3DPrefix(@enum.Name);
            bool isBitflag = name.EndsWith("Flags");
            string enumName = isBitflag ? name[..^5] : name;

            var sb = new StringBuilder();
            sb.AppendLine("// Auto-generated by R3D-cs.GenerateBindings");
            sb.AppendLine("// Do not edit manually");
            sb.AppendLine();
            sb.AppendLine($"namespace {Namespace};");
            sb.AppendLine();

            CommentGenerator.Generate(sb, @enum.Comment, @enum.Name);

            if (isBitflag)
                sb.AppendLine("[Flags]");

            sb.Append($"public enum {name}");
            (string type, _, _, _) = MapType(@enum.IntegerType);
            if (type != "int")
                sb.Append($" : {type}");
            sb.AppendLine();
            sb.AppendLine("{");

            string prefix = name;
            if (name.EndsWith("Mode", StringComparison.OrdinalIgnoreCase)) prefix = name[..^4];
            if (name.EndsWith("Type", StringComparison.OrdinalIgnoreCase)) prefix = name[..^4];

            for (var i = 0; i < @enum.Items.Count; i++)
            {
                var item = @enum.Items[i];
                string itemName = ToPascalCase(StripR3DPrefix(item.Name));

                if (itemName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                    itemName = itemName[prefix.Length..];

                bool hasComment = CommentGenerator.Generate(sb, item.Comment, $"{@enum.Name}.{item.Name}", "    ");

                if (isBitflag)
                    sb.AppendLine($"    {itemName} = {item.Value},");
                else
                    sb.AppendLine($"    {itemName},");

                if (i < @enum.Items.Count - 1 && hasComment)
                    sb.AppendLine();
            }

            sb.AppendLine("}");

            File.WriteAllText(Path.Combine(outputDir, "enums", $"{enumName}.g.cs"), sb.ToString());
            count++;
        }

        return count;
    }

    /// <summary>
    ///     Explicit count expressions for pointer fields whose counts live in nested structs.
    /// </summary>
    private static readonly Dictionary<(string structName, string cFieldName), string> ExplicitCountExpressions = new()
    {
        [("R3D_AnimationPlayer", "states")] = "AnimLib.Count",
        [("R3D_AnimationPlayer", "localPose")] = "Skeleton.BoneCount",
        [("R3D_AnimationPlayer", "modelPose")] = "Skeleton.BoneCount",
        [("R3D_AnimationPlayer", "skinBuffer")] = "Skeleton.BoneCount",
    };

    /// <summary>
    ///     Finds the C# count expression for a pointer field by prefix-matching count fields,
    ///     falling back to a generic "Count" field, a lone count field, or the explicit map.
    /// </summary>
    /// <summary>
    ///     Returns the number of leading characters shared by two strings (case-insensitive).
    /// </summary>
    private static int CommonPrefixLength(string a, string b)
    {
        int len = Math.Min(a.Length, b.Length);
        for (var i = 0; i < len; i++)
        {
            if (char.ToUpperInvariant(a[i]) != char.ToUpperInvariant(b[i]))
                return i;
        }
        return len;
    }

    private static string? FindCountExpression(
        string nativeStructName,
        string cFieldName,
        string csFieldName,
        List<(string csName, string cName)> countFields)
    {
        // 1. Check explicit overrides (for nested-struct counts like AnimLib.Count)
        if (ExplicitCountExpressions.TryGetValue((nativeStructName, cFieldName), out string? expr))
            return expr;

        // 2. Common-prefix match: count field name minus "Count" must share a significant
        //    common prefix with the pointer field name.  This handles Latin plurals where
        //    the singular is NOT a prefix of the plural (Vertex→Vertices, Index→Indices).
        string? bestMatch = null;
        var bestLen = 0;
        foreach (var (csName, _) in countFields)
        {
            if (csName.Length <= 5 || !csName.EndsWith("Count", StringComparison.OrdinalIgnoreCase))
                continue;

            string prefix = csName[..^5];
            int commonLen = CommonPrefixLength(csFieldName, prefix);
            int threshold = Math.Max(3, prefix.Length - 2);

            if (commonLen >= threshold && commonLen > bestLen)
            {
                bestMatch = csName;
                bestLen = commonLen;
            }
        }
        if (bestMatch != null)
            return bestMatch;

        // 3. Exact "Count" field
        var exact = countFields.FirstOrDefault(c =>
            c.csName.Equals("Count", StringComparison.OrdinalIgnoreCase));
        if (exact.csName != null)
            return exact.csName;

        // 4. Lone count field (only one int*Count field in the struct → shared count)
        if (countFields.Count == 1)
            return countFields[0].csName;

        return null;
    }

    private int GenerateStructsFiles(CppCompilation compilation)
    {
        var count = 0;

        foreach (var @class in compilation.Classes)
        {
            if (!IsR3DSource(@class.SourceFile))
                continue;

            if (@class.ClassKind != CppClassKind.Struct)
                throw new Exception($"Unexpected class kind: {@class.ClassKind}");

            var sb = new StringBuilder();
            GenerateHeader(sb, ["System", "System.Numerics", "System.Runtime.InteropServices", "Raylib_cs"]);

            string className = StripR3DPrefix(@class.Name);
            bool needsUnsafe = @class.Fields.Select(f => MapType(f.Type)).Any(r => r.isUnsafe);

            CommentGenerator.Generate(sb, @class.Comment, @class.Name);

            bool isOpaque = TypeMapper.OpaqueTypes.Contains(@class.Name);

            sb.AppendLine("[StructLayout(LayoutKind.Sequential)]");
            sb.Append($"public {(needsUnsafe ? "unsafe " : "")}struct {className}");
            sb.AppendLine();
            sb.AppendLine("{");

            if (isOpaque)
            {
                sb.AppendLine("    private nint _handle;");
            }

            // Collect metadata for Span property generation
            var pointerFields = new List<(string emitName, string elementType, string originalName, string cFieldName)>();
            var voidPointerFields = new List<(string emitName, string originalName, string cFieldName)>();
            var countFields = new List<(string csName, string cName)>();

            foreach (var field in @class.Fields)
            {
                (string csType, _, bool isFixedBuffer, int fixedSize) = MapType(field.Type);

                string fieldType = StripR3DPrefix(csType);
                string fieldName = EscapeIdentifier(ToPascalCase(field.Name));

                // Override for callbacks
                if (fieldName.EndsWith("Callback", StringComparison.OrdinalIgnoreCase))
                    fieldType = "IntPtr";

                // Typed pointer fields become internal with _ prefix
                bool isTypedPointer = !isFixedBuffer
                    && !isOpaque
                    && fieldType.Contains('*')
                    && fieldType != "void*";

                string access = isTypedPointer ? "internal" : "public";
                string emitName = isTypedPointer
                    ? $"_{char.ToLower(fieldName[0])}{fieldName[1..]}"
                    : fieldName;

                if (isTypedPointer)
                {
                    string elementType = fieldType.Replace("*", "").Trim();
                    pointerFields.Add((emitName, elementType, fieldName, field.Name));
                }

                if (!isFixedBuffer && fieldType == "void*")
                    voidPointerFields.Add((emitName, fieldName, field.Name));

                if (!isFixedBuffer && fieldType is "int" or "uint"
                    && fieldName.EndsWith("Count", StringComparison.OrdinalIgnoreCase))
                    countFields.Add((fieldName, field.Name));

                CommentGenerator.Generate(sb, field.Comment, field.Name, "    ");

                if (isFixedBuffer)
                    sb.AppendLine($"    {access} fixed {fieldType} {emitName}[{fixedSize}];");
                else
                    sb.AppendLine($"    {access} {fieldType} {emitName};");

                sb.AppendLine();
            }

            // Emit Span<T> properties for typed pointer + count pairs
            foreach (var (emitName, elementType, originalName, cFieldName) in pointerFields)
            {
                string? countExpr = FindCountExpression(@class.Name, cFieldName, originalName, countFields);
                if (countExpr == null) continue;

                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// <see cref=\"{originalName}\"/> as a <see cref=\"Span{{T}}\"/>.");
                sb.AppendLine("    /// </summary>");
                sb.AppendLine($"    public Span<{elementType}> {originalName} => {emitName} != null ? new({emitName}, {countExpr}) : default;");
                sb.AppendLine();
            }

            // Emit generic cast method for void* pointer + count pairs
            foreach (var (emitName, originalName, cFieldName) in voidPointerFields)
            {
                string? countExpr = FindCountExpression(@class.Name, cFieldName, originalName, countFields);
                if (countExpr == null) continue;

                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// <see cref=\"{originalName}\"/> cast to the specified type as a <see cref=\"Span{{T}}\"/>.");
                sb.AppendLine("    /// </summary>");
                sb.AppendLine($"    public Span<T> {originalName}As<T>() where T : unmanaged => {emitName} != null ? new((T*){emitName}, {countExpr}) : default;");
                sb.AppendLine();
            }

            sb.AppendLine("}");

            File.WriteAllText(Path.Combine(outputDir, "types", $"{className}.g.cs"), sb.ToString());
            count++;
        }

        return count;
    }

    private int GenerateMiscFiles(CppCompilation compilation)
    {
        var count = 0;

        foreach (var typedef in compilation.Typedefs)
        {
            if (!IsR3DSource(typedef.SourceFile))
                continue;

            string name = StripR3DPrefix(typedef.Name);

            // Callbacks (function pointers)
            if (typedef.Name.EndsWith("Callback"))
            {
                if (typedef.ElementType is CppPointerType { ElementType: CppFunctionType funcType })
                {
                    (string returnType, _, _, _) = MapType(funcType.ReturnType);

                    var sb = new StringBuilder();
                    GenerateHeader(sb, ["System", "System.Numerics", "System.Runtime.InteropServices", "Raylib_cs"]);

                    CommentGenerator.Generate(sb, typedef.Comment, typedef.Name);

                    sb.AppendLine("[UnmanagedFunctionPointer(CallingConvention.Cdecl)]");
                    sb.Append($"public unsafe delegate {returnType} {name}(");

                    for (var i = 0; i < funcType.Parameters.Count; i++)
                    {
                        var param = funcType.Parameters[i];

                        (string paramType, _, _, _) = MapType(param.Type);
                        sb.Append($"{StripR3DPrefix(paramType)} {param.Name}");

                        if (i < funcType.Parameters.Count - 1)
                            sb.Append(", ");
                    }

                    sb.AppendLine(");");
                    sb.AppendLine();

                    File.WriteAllText(Path.Combine(outputDir, "types", $"{name}.g.cs"), sb.ToString());
                    count++;
                }

                continue;
            }

            // Check for macro-based enums
            bool isBitflag = name.EndsWith("Flags");
            string enumName = isBitflag ? name[..^5] : name;
            string prefix = "R3D_" + enumName.ToUpperInvariant() + "_";

            var options = new List<CppMacro>();
            foreach (var macro in compilation.Macros)
            {
                if (macro.SourceFile != typedef.SourceFile || macro.Span.Start.Line < typedef.Span.End.Line)
                    continue;

                if (!macro.Name.StartsWith(prefix))
                    continue;

                options.Add(macro);
            }

            if (options.Count > 0)
            {
                var sb = new StringBuilder();
                GenerateHeader(sb, ["System", "System.Numerics", "System.Runtime.InteropServices", "Raylib_cs"]);

                CommentGenerator.Generate(sb, typedef.Comment, typedef.Name);

                sb.AppendLine("[Flags]");
                sb.Append($"public enum {name}");
                (string type, _, _, _) = MapType(typedef.ElementType);
                if (type != "int")
                    sb.Append($" : {type}");
                sb.AppendLine();
                sb.AppendLine("{");

                for (var i = 0; i < options.Count; i++)
                {
                    var macro = options[i];

                    string optionName = ToPascalCase(macro.Name[prefix.Length..]);

                    if (optionName.All(char.IsDigit))
                        optionName = ToPascalCase(StripR3DPrefix(macro.Name));

                    if (optionName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                        optionName = optionName[prefix.Length..];

                    bool hasComment = CommentGenerator.GenerateForMacro(sb, macro, macro.Name, "    ");

                    sb.AppendLine($"    {optionName} = {macro.Value},");

                    if (i < options.Count - 1 && hasComment)
                        sb.AppendLine();
                }

                sb.AppendLine("}");

                File.WriteAllText(Path.Combine(outputDir, "enums", $"{name}.g.cs"), sb.ToString());
                count++;
                continue;
            }

            // Opaque handle types (typedef int32_t R3D_Something)
            if (typedef.ElementType is CppPrimitiveType { Kind: CppPrimitiveKind.Int })
            {
                var sb = new StringBuilder();
                GenerateHeader(sb);

                CommentGenerator.Generate(sb, typedef.Comment, typedef.Name);

                sb.AppendLine($"public struct {name}");
                sb.AppendLine("{");
                sb.AppendLine("    internal int id;");
                sb.AppendLine();
                sb.AppendLine($"    public static explicit operator int({name} handle) => handle.id;");
                sb.AppendLine($"    public static explicit operator {name}(int id) => new() {{ id = id }};");
                sb.AppendLine("}");

                File.WriteAllText(Path.Combine(outputDir, "types", $"{name}.g.cs"), sb.ToString());
                count++;
            }
        }

        return count;
    }

    private int GenerateInteropFiles(CppCompilation compilation, string version)
    {
        var funcCount = 0;

        var functions =  compilation.Functions
            .Where(f => IsR3DSource(f.SourceFile))
            .GroupBy(f => Path.GetFileNameWithoutExtension(f.SourceFile));

        foreach (var group in functions)
        {
            var sb = new StringBuilder();
            if (group.Key == "r3d_core")
            {
                GenerateHeader(sb,
                    ["System", "System.Numerics", "System.Runtime.CompilerServices", "System.Runtime.InteropServices", "System.Security", "Raylib_cs", "static Raylib_cs.Raylib"],
                    ["[assembly: DisableRuntimeMarshalling]"]
                );
            }
            else
            {
                GenerateHeader(sb,
                    ["System", "System.Numerics", "System.Runtime.CompilerServices", "System.Runtime.InteropServices", "System.Security", "Raylib_cs", "static Raylib_cs.Raylib"]
                );
            }

            sb.AppendLine($"// {group.Key}.h;");
            sb.AppendLine();
            sb.AppendLine("[SuppressUnmanagedCodeSecurity]");
            sb.AppendLine("public static unsafe partial class R3D");
            sb.AppendLine("{");
            sb.AppendLine();
            if (group.Key == "r3d_core")
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine("    /// Used by DllImport to load the native library");
                sb.AppendLine("    /// </summary>");
                sb.AppendLine($"    public const string NativeLibName = \"{NativeLibName}\";");
                sb.AppendLine();
                sb.AppendLine($"    public const string R3D_VERSION = \"{version}\";");
                sb.AppendLine();
            }

            foreach (var function in group)
            {
                string? name = function.Name;
                (string returnType, _, _, _) = MapType(function.ReturnType);
                bool hasStringParam = function.Parameters.Any(p => p.Type is CppPointerType
                {
                    ElementType: CppQualifiedType { ElementType: CppPrimitiveType { Kind: CppPrimitiveKind.Char } }
                });

                CommentGenerator.Generate(sb, function.Comment, name, "    ");

                sb.Append("    [LibraryImport(NativeLibName");
                sb.Append($", EntryPoint = \"{name}\"");
                if (hasStringParam)
                    sb.Append(", StringMarshalling = StringMarshalling.Utf8");
                sb.AppendLine(")]");

                if (returnType == "bool")
                    sb.AppendLine("    [return: MarshalAs(UnmanagedType.I1)]");

                sb.Append($"    public static partial {StripR3DPrefix(returnType)} {StripR3DPrefix(name)}(");
                for (var i = 0; i < function.Parameters.Count; i++)
                {
                    if (i > 0)
                        sb.Append(", ");

                    var param = function.Parameters[i];
                    (string paramType, _, _, _) = MapType(param.Type);

                    if (paramType == "bool")
                        sb.Append("[MarshalAs(UnmanagedType.I1)] ");

                    // Convert pointer parameters to ref/out where appropriate
                    (string? modifier, string finalType) = GetParameterModifier(param.Type, paramType, name);
                    if (modifier != null)
                        sb.Append($"{modifier} ");

                    sb.Append($"{StripR3DPrefix(finalType)} {EscapeIdentifier(StripR3DPrefix(param.Name))}");
                }

                sb.AppendLine(");");
                sb.AppendLine();

                funcCount++;
            }

            sb.AppendLine("}");

            File.WriteAllText(Path.Combine(outputDir, "interop", $"R3D.{group.Key.Replace("r3d_", "")}.g.cs"), sb.ToString());
        }

        return funcCount;
    }

    private void GenerateHeader(StringBuilder sb, List<string>? includes = null, List<string>? other = null)
    {
        sb.AppendLine("// Auto-generated by R3D-cs.GenerateBindings");
        sb.AppendLine("// Do not edit manually");
        sb.AppendLine();
        if (includes != null)
        {
            foreach (string include in includes)
                sb.AppendLine($"using {include};");
            sb.AppendLine();
        }

        if (other != null)
        {
            foreach (string line in other)
                sb.AppendLine(line);
            sb.AppendLine();
        }

        sb.AppendLine($"namespace {Namespace};");
        sb.AppendLine();
    }

    private bool IsR3DSource(string? sourceFile)
    {
        if (sourceFile == null)
            return false;

        // Normalize path separators for cross-platform compatibility
        char sep = Path.DirectorySeparatorChar;
        string normalized = sourceFile.Replace('/', sep).Replace('\\', sep);
        return normalized.Contains($"include{sep}r3d{sep}");
    }

    private static void ClearDirectory(string directory)
    {
        if (Directory.Exists(directory))
            // Only delete generated files (*.g.cs), preserve hand-written files
            foreach (string file in Directory.GetFiles(directory, "*.g.cs"))
                File.Delete(file);
        else
            Directory.CreateDirectory(directory);
    }
}
